use super::lexer::*;
use super::ast::*;
use self::KeywordType::*;
use self::LexToken::*;
use self::LexSymbol::*;

grammar<'input>;

extern {
    type Location = Pos;
    type Error = LexicalError<usize>;

    enum LexToken<'input> {
        IDENT       => Ident(<&'input str>),
        LIFETIME    => Lifetime(<&'input str>),
        INNERDOC    => InnerDoc(<&'input str>),
        OUTERDOC    => OuterDoc(<&'input str>),
        LITERAL     => Literal(<LiteralType>),

        ">_"        => AmbigGt,

        "["         => Symbol(LBracket),
        "]"         => Symbol(RBracket),
        "("         => Symbol(LParen),
        ")"         => Symbol(RParen),
        "{"         => Symbol(LBrace),
        "}"         => Symbol(RBrace),
        ","         => Symbol(Comma),
        ";"         => Symbol(Semi),
        "@"         => Symbol(At),
        "#"         => Symbol(Hash),
        "$"         => Symbol(Dollar),
        "?"         => Symbol(Question),
        "."         => Symbol(Dot),
        ".."        => Symbol(DotDot),
        "..."       => Symbol(DotDotDot),
        ":"         => Symbol(Colon),
        "::"        => Symbol(ColonColon),
        "!"         => Symbol(Bang),
        "<-"        => Symbol(LArrow),
        "->"        => Symbol(RArrow),
        "=>"        => Symbol(RFatArrow),

        "+"         => Symbol(Add),
        "-"         => Symbol(Sub),
        "*"         => Symbol(Mul),
        "/"         => Symbol(Div),
        "%"         => Symbol(Mod),
        "&"         => Symbol(And),
        "|"         => Symbol(Or),
        "^"         => Symbol(Xor),
        "<<"        => Symbol(Shl),
        "&&"        => Symbol(AndAnd),
        "||"        => Symbol(OrOr),
        "=="        => Symbol(EqEq),
        "!="        => Symbol(Ne),
        "<"         => Symbol(Lt),
        ">"         => Symbol(Gt),
        "<="        => Symbol(Le),
        "="         => Symbol(Eq),
        "+="        => Symbol(AddEq),
        "-="        => Symbol(SubEq),
        "*="        => Symbol(MulEq),
        "/="        => Symbol(DivEq),
        "%="        => Symbol(ModEq),
        "&="        => Symbol(AndEq),
        "|="        => Symbol(OrEq),
        "^="        => Symbol(XorEq),
        "<<="       => Symbol(ShlEq),

        // keywords
        "abstract"  => Keyword(KwAbstract),
        "alignof"   => Keyword(KwAlignof),
        "as"        => Keyword(KwAs),
        "become"    => Keyword(KwBecome),
        "box"       => Keyword(KwBox),
        "break"     => Keyword(KwBreak),
        "const"     => Keyword(KwConst),
        "continue"  => Keyword(KwContinue),
        "crate"     => Keyword(KwCrate),
        "do"        => Keyword(KwDo),
        "else"      => Keyword(KwElse),
        "enum"      => Keyword(KwEnum),
        "extern"    => Keyword(KwExtern),
        "false"     => Keyword(KwFalse),
        "final"     => Keyword(KwFinal),
        "fn"        => Keyword(KwFn),
        "for"       => Keyword(KwFor),
        "if"        => Keyword(KwIf),
        "impl"      => Keyword(KwImpl),
        "in"        => Keyword(KwIn),
        "let"       => Keyword(KwLet),
        "loop"      => Keyword(KwLoop),
        "macro"     => Keyword(KwMacro),
        "match"     => Keyword(KwMatch),
        "mod"       => Keyword(KwMod),
        "move"      => Keyword(KwMove),
        "mut"       => Keyword(KwMut),
        "offsetof"  => Keyword(KwOffsetof),
        "override"  => Keyword(KwOverride),
        "priv"      => Keyword(KwPriv),
        "proc"      => Keyword(KwProc),
        "pub"       => Keyword(KwPub),
        "pure"      => Keyword(KwPure),
        "ref"       => Keyword(KwRef),
        "return"    => Keyword(KwReturn),
        "Self"      => Keyword(KwSelfTy),
        "self"      => Keyword(KwSelfVar),
        "sizeof"    => Keyword(KwSizeof),
        "static"    => Keyword(KwStatic),
        "struct"    => Keyword(KwStruct),
        "super"     => Keyword(KwSuper),
        "trait"     => Keyword(KwTrait),
        "true"      => Keyword(KwTrue),
        "type"      => Keyword(KwType),
        "typeof"    => Keyword(KwTypeof),
        "unsafe"    => Keyword(KwUnsafe),
        "unsized"   => Keyword(KwUnsized),
        "use"       => Keyword(KwUse),
        "virtual"   => Keyword(KwVirtual),
        "where"     => Keyword(KwWhere),
        "while"     => Keyword(KwWhile),
        "yield"     => Keyword(KwYield),
    }
}

op_shr      = ">_" ">";
op_shreq    = ">_" ">_" "=";

symbol: &'static str = {
    op_shreq    => ">>=",
    op_shr      => ">>",

    ","         => ",",
    ";"         => ";",
    "@"         => "@",
    "#"         => "#",
    "$"         => "$",
    "?"         => "?",
    "."         => ".",
    ".."        => "..",
    "..."       => "...",
    ":"         => ":",
    "::"        => "::",
    "!"         => "!",
    "<-"        => "<-",
    "->"        => "->",
    "=>"        => "=>",

    "+"         => "+",
    "-"         => "-",
    "*"         => "*",
    "/"         => "/",
    "%"         => "%",
    "&"         => "&",
    "|"         => "|",
    "^"         => "^",
    "<<"        => "<<",
    "&&"        => "&&",
    "||"        => "||",
    "=="        => "==",
    "!="        => "!=",
    "<"         => "<",
    ">"         => ">",
    "<="        => "<=",
    "="         => "=",
    "+="        => "+=",
    "-="        => "-=",
    "*="        => "*=",
    "/="        => "/=",
    "%="        => "%=",
    "&="        => "&=",
    "|="        => "|=",
    "^="        => "^=",
    "<<="       => "<<=",
};

keyword: KeywordType = {
    "abstract"  => KwAbstract,
    "alignof"   => KwAlignof,
    "as"        => KwAs,
    "become"    => KwBecome,
    "box"       => KwBox,
    "break"     => KwBreak,
    "const"     => KwConst,
    "continue"  => KwContinue,
    "crate"     => KwCrate,
    "do"        => KwDo,
    "else"      => KwElse,
    "enum"      => KwEnum,
    "extern"    => KwExtern,
    "false"     => KwFalse,
    "final"     => KwFinal,
    "fn"        => KwFn,
    "for"       => KwFor,
    "if"        => KwIf,
    "impl"      => KwImpl,
    "in"        => KwIn,
    "let"       => KwLet,
    "loop"      => KwLoop,
    "macro"     => KwMacro,
    "match"     => KwMatch,
    "mod"       => KwMod,
    "move"      => KwMove,
    "mut"       => KwMut,
    "offsetof"  => KwOffsetof,
    "override"  => KwOverride,
    "priv"      => KwPriv,
    "proc"      => KwProc,
    "pub"       => KwPub,
    "pure"      => KwPure,
    "ref"       => KwRef,
    "return"    => KwReturn,
    "Self"      => KwSelfTy,
    "self"      => KwSelfVar,
    "sizeof"    => KwSizeof,
    "static"    => KwStatic,
    "struct"    => KwStruct,
    "super"     => KwSuper,
    "trait"     => KwTrait,
    "true"      => KwTrue,
    "type"      => KwType,
    "typeof"    => KwTypeof,
    "unsafe"    => KwUnsafe,
    "unsized"   => KwUnsized,
    "use"       => KwUse,
    "virtual"   => KwVirtual,
    "where"     => KwWhere,
    "while"     => KwWhile,
    "yield"     => KwYield,
};

// Token tree
pub tts: Vec<Token<'input>> = tt*;

pub tt: Token<'input> = {
    "(" <tts> ")"   => Token::Delimited(Delimiter::Paren, <>),
    "[" <tts> "]"   => Token::Delimited(Delimiter::Bracket, <>),
    "{" <tts> "}"   => Token::Delimited(Delimiter::Brace, <>),
    keyword         => Token::Keyword(<>),
    IDENT           => Token::Ident(<>),
    LIFETIME        => Token::Lifetime(<>),
    symbol          => Token::Symbol(<>),
    LITERAL         => Token::Literal(<>),
    INNERDOC        => Token::InnerDoc(<>),
    OUTERDOC        => Token::OuterDoc(<>),
};
