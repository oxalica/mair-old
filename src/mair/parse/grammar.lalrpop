use super::lexer::*;
use super::ast::*;
use self::Keyword::*;

grammar<'input>;

extern {
    type Location = Pos;
    type Error = LexicalError<usize>;

    enum LexToken<'input> {
        IDENT       => LexToken::Ident(<&'input str>),
        LIFETIME    => LexToken::Lifetime(<&'input str>),
        INNERDOC    => LexToken::InnerDoc(<&'input str>),
        OUTERDOC    => LexToken::OuterDoc(<&'input str>),
        LITERAL     => LexToken::Literal(<LiteralType>),

        ">_"        => LexToken::AmbigGt,

        "["         => LexToken::Symbol(LexSymbol::LBracket),
        "]"         => LexToken::Symbol(LexSymbol::RBracket),
        "("         => LexToken::Symbol(LexSymbol::LParen),
        ")"         => LexToken::Symbol(LexSymbol::RParen),
        "{"         => LexToken::Symbol(LexSymbol::LBrace),
        "}"         => LexToken::Symbol(LexSymbol::RBrace),
        ","         => LexToken::Symbol(LexSymbol::Comma),
        ";"         => LexToken::Symbol(LexSymbol::Semi),
        "@"         => LexToken::Symbol(LexSymbol::At),
        "#"         => LexToken::Symbol(LexSymbol::Hash),
        "$"         => LexToken::Symbol(LexSymbol::Dollar),
        "?"         => LexToken::Symbol(LexSymbol::Question),
        "."         => LexToken::Symbol(LexSymbol::Dot),
        ".."        => LexToken::Symbol(LexSymbol::DotDot),
        "..."       => LexToken::Symbol(LexSymbol::DotDotDot),
        ":"         => LexToken::Symbol(LexSymbol::Colon),
        "::"        => LexToken::Symbol(LexSymbol::ColonColon),
        "!"         => LexToken::Symbol(LexSymbol::Bang),
        "<-"        => LexToken::Symbol(LexSymbol::LArrow),
        "->"        => LexToken::Symbol(LexSymbol::RArrow),
        "=>"        => LexToken::Symbol(LexSymbol::RFatArrow),

        "+"         => LexToken::Symbol(LexSymbol::Add),
        "-"         => LexToken::Symbol(LexSymbol::Sub),
        "*"         => LexToken::Symbol(LexSymbol::Mul),
        "/"         => LexToken::Symbol(LexSymbol::Div),
        "%"         => LexToken::Symbol(LexSymbol::Mod),
        "&"         => LexToken::Symbol(LexSymbol::And),
        "|"         => LexToken::Symbol(LexSymbol::Or),
        "^"         => LexToken::Symbol(LexSymbol::Xor),
        "<<"        => LexToken::Symbol(LexSymbol::Shl),
        "&&"        => LexToken::Symbol(LexSymbol::AndAnd),
        "||"        => LexToken::Symbol(LexSymbol::OrOr),
        "=="        => LexToken::Symbol(LexSymbol::EqEq),
        "!="        => LexToken::Symbol(LexSymbol::Ne),
        "<"         => LexToken::Symbol(LexSymbol::Lt),
        ">"         => LexToken::Symbol(LexSymbol::Gt),
        "<="        => LexToken::Symbol(LexSymbol::Le),
        "="         => LexToken::Symbol(LexSymbol::Eq),
        "+="        => LexToken::Symbol(LexSymbol::AddEq),
        "-="        => LexToken::Symbol(LexSymbol::SubEq),
        "*="        => LexToken::Symbol(LexSymbol::MulEq),
        "/="        => LexToken::Symbol(LexSymbol::DivEq),
        "%="        => LexToken::Symbol(LexSymbol::ModEq),
        "&="        => LexToken::Symbol(LexSymbol::AndEq),
        "|="        => LexToken::Symbol(LexSymbol::OrEq),
        "^="        => LexToken::Symbol(LexSymbol::XorEq),
        "<<="       => LexToken::Symbol(LexSymbol::ShlEq),

        // keywords
        "abstract"  => LexToken::Keyword(KwAbstract),
        "alignof"   => LexToken::Keyword(KwAlignof),
        "as"        => LexToken::Keyword(KwAs),
        "become"    => LexToken::Keyword(KwBecome),
        "box"       => LexToken::Keyword(KwBox),
        "break"     => LexToken::Keyword(KwBreak),
        "const"     => LexToken::Keyword(KwConst),
        "continue"  => LexToken::Keyword(KwContinue),
        "crate"     => LexToken::Keyword(KwCrate),
        "do"        => LexToken::Keyword(KwDo),
        "else"      => LexToken::Keyword(KwElse),
        "enum"      => LexToken::Keyword(KwEnum),
        "extern"    => LexToken::Keyword(KwExtern),
        "false"     => LexToken::Keyword(KwFalse),
        "final"     => LexToken::Keyword(KwFinal),
        "fn"        => LexToken::Keyword(KwFn),
        "for"       => LexToken::Keyword(KwFor),
        "if"        => LexToken::Keyword(KwIf),
        "impl"      => LexToken::Keyword(KwImpl),
        "in"        => LexToken::Keyword(KwIn),
        "let"       => LexToken::Keyword(KwLet),
        "loop"      => LexToken::Keyword(KwLoop),
        "macro"     => LexToken::Keyword(KwMacro),
        "match"     => LexToken::Keyword(KwMatch),
        "mod"       => LexToken::Keyword(KwMod),
        "move"      => LexToken::Keyword(KwMove),
        "mut"       => LexToken::Keyword(KwMut),
        "offsetof"  => LexToken::Keyword(KwOffsetof),
        "override"  => LexToken::Keyword(KwOverride),
        "priv"      => LexToken::Keyword(KwPriv),
        "proc"      => LexToken::Keyword(KwProc),
        "pub"       => LexToken::Keyword(KwPub),
        "pure"      => LexToken::Keyword(KwPure),
        "ref"       => LexToken::Keyword(KwRef),
        "return"    => LexToken::Keyword(KwReturn),
        "Self"      => LexToken::Keyword(KwSelfTy),
        "self"      => LexToken::Keyword(KwSelfVar),
        "sizeof"    => LexToken::Keyword(KwSizeof),
        "static"    => LexToken::Keyword(KwStatic),
        "struct"    => LexToken::Keyword(KwStruct),
        "super"     => LexToken::Keyword(KwSuper),
        "trait"     => LexToken::Keyword(KwTrait),
        "true"      => LexToken::Keyword(KwTrue),
        "type"      => LexToken::Keyword(KwType),
        "typeof"    => LexToken::Keyword(KwTypeof),
        "unsafe"    => LexToken::Keyword(KwUnsafe),
        "unsized"   => LexToken::Keyword(KwUnsized),
        "use"       => LexToken::Keyword(KwUse),
        "virtual"   => LexToken::Keyword(KwVirtual),
        "where"     => LexToken::Keyword(KwWhere),
        "while"     => LexToken::Keyword(KwWhile),
        "yield"     => LexToken::Keyword(KwYield),
    }
}

op_gt       = { ">_", ">" };
op_shr      = ">_" ">";
op_shreq    = ">_" ">_" "=";

symbol: &'static str = {
    op_shreq    => ">>=",
    op_shr      => ">>",

    ","         => ",",
    ";"         => ";",
    "@"         => "@",
    "#"         => "#",
    "$"         => "$",
    "?"         => "?",
    "."         => ".",
    ".."        => "..",
    "..."       => "...",
    ":"         => ":",
    "::"        => "::",
    "!"         => "!",
    "<-"        => "<-",
    "->"        => "->",
    "=>"        => "=>",

    "+"         => "+",
    "-"         => "-",
    "*"         => "*",
    "/"         => "/",
    "%"         => "%",
    "&"         => "&",
    "|"         => "|",
    "^"         => "^",
    "<<"        => "<<",
    "&&"        => "&&",
    "||"        => "||",
    "=="        => "==",
    "!="        => "!=",
    "<"         => "<",
    ">"         => ">",
    "<="        => "<=",
    "="         => "=",
    "+="        => "+=",
    "-="        => "-=",
    "*="        => "*=",
    "/="        => "/=",
    "%="        => "%=",
    "&="        => "&=",
    "|="        => "|=",
    "^="        => "^=",
    "<<="       => "<<=",
};

keyword: Keyword = {
    "abstract"  => KwAbstract,
    "alignof"   => KwAlignof,
    "as"        => KwAs,
    "become"    => KwBecome,
    "box"       => KwBox,
    "break"     => KwBreak,
    "const"     => KwConst,
    "continue"  => KwContinue,
    "crate"     => KwCrate,
    "do"        => KwDo,
    "else"      => KwElse,
    "enum"      => KwEnum,
    "extern"    => KwExtern,
    "false"     => KwFalse,
    "final"     => KwFinal,
    "fn"        => KwFn,
    "for"       => KwFor,
    "if"        => KwIf,
    "impl"      => KwImpl,
    "in"        => KwIn,
    "let"       => KwLet,
    "loop"      => KwLoop,
    "macro"     => KwMacro,
    "match"     => KwMatch,
    "mod"       => KwMod,
    "move"      => KwMove,
    "mut"       => KwMut,
    "offsetof"  => KwOffsetof,
    "override"  => KwOverride,
    "priv"      => KwPriv,
    "proc"      => KwProc,
    "pub"       => KwPub,
    "pure"      => KwPure,
    "ref"       => KwRef,
    "return"    => KwReturn,
    "Self"      => KwSelfTy,
    "self"      => KwSelfVar,
    "sizeof"    => KwSizeof,
    "static"    => KwStatic,
    "struct"    => KwStruct,
    "super"     => KwSuper,
    "trait"     => KwTrait,
    "true"      => KwTrue,
    "type"      => KwType,
    "typeof"    => KwTypeof,
    "unsafe"    => KwUnsafe,
    "unsized"   => KwUnsized,
    "use"       => KwUse,
    "virtual"   => KwVirtual,
    "where"     => KwWhere,
    "while"     => KwWhile,
    "yield"     => KwYield,
};

pub tts: Vec<Token<'input>> = tt*;

pub tt: Token<'input> = {
    "(" <tts> ")"   => Token::Delimited(Delimiter::Paren, <>),
    "[" <tts> "]"   => Token::Delimited(Delimiter::Bracket, <>),
    "{" <tts> "}"   => Token::Delimited(Delimiter::Brace, <>),
    keyword         => Token::Keyword(<>),
    IDENT           => Token::Ident(<>),
    LIFETIME        => Token::Lifetime(<>),
    symbol          => Token::Symbol(<>),
    LITERAL         => Token::Literal(<>),
    INNERDOC        => Token::InnerDoc(<>),
    OUTERDOC        => Token::OuterDoc(<>),
};
