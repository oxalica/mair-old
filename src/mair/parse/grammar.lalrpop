// The whole file is wrapped in mod mair::parse::grammar::parser.
use super::super::*;
use self::lexer::*;
use self::ast::*;
use self::ast::Literal as Lit;
use self::KeywordType::*;
use self::LexToken::*;
use self::LexSymbol::*;
use super::{is_placeholder, merge_templ};

grammar<'input>;

extern {
    type Location = Pos;
    type Error = LexicalError<usize>;

    enum LexToken<'input> {
        IDENT       => Ident(<&'input str>),
        LIFETIME    => Lifetime(<&'input str>),
        INNERDOC    => InnerDoc(<&'input str>),
        OUTERDOC    => OuterDoc(<&'input str>),
        LITERAL     => Literal(<Lit<'input>>),

        ">_"        => AmbigGt,

        "["         => Symbol(LBracket),
        "]"         => Symbol(RBracket),
        "("         => Symbol(LParen),
        ")"         => Symbol(RParen),
        "{"         => Symbol(LBrace),
        "}"         => Symbol(RBrace),
        ","         => Symbol(Comma),
        ";"         => Symbol(Semi),
        "@"         => Symbol(At),
        "#"         => Symbol(Hash),
        "$"         => Symbol(Dollar),
        "?"         => Symbol(Question),
        "."         => Symbol(Dot),
        ".."        => Symbol(DotDot),
        "..."       => Symbol(DotDotDot),
        ":"         => Symbol(Colon),
        "::"        => Symbol(ColonColon),
        "!"         => Symbol(Bang),
        "<-"        => Symbol(LArrow),
        "->"        => Symbol(RArrow),
        "=>"        => Symbol(RFatArrow),

        "+"         => Symbol(Add),
        "-"         => Symbol(Sub),
        "*"         => Symbol(Mul),
        "/"         => Symbol(Div),
        "%"         => Symbol(Mod),
        "&"         => Symbol(And),
        "|"         => Symbol(Or),
        "^"         => Symbol(Xor),
        "<<"        => Symbol(Shl),
        "&&"        => Symbol(AndAnd),
        "||"        => Symbol(OrOr),
        "=="        => Symbol(EqEq),
        "!="        => Symbol(Ne),
        "<"         => Symbol(Lt),
        ">"         => Symbol(Gt),
        "<="        => Symbol(Le),
        "="         => Symbol(Eq),
        "+="        => Symbol(AddEq),
        "-="        => Symbol(SubEq),
        "*="        => Symbol(MulEq),
        "/="        => Symbol(DivEq),
        "%="        => Symbol(ModEq),
        "&="        => Symbol(AndEq),
        "|="        => Symbol(OrEq),
        "^="        => Symbol(XorEq),
        "<<="       => Symbol(ShlEq),

        // keywords
        "abstract"  => Keyword(KwAbstract),
        "alignof"   => Keyword(KwAlignof),
        "as"        => Keyword(KwAs),
        "become"    => Keyword(KwBecome),
        "box"       => Keyword(KwBox),
        "break"     => Keyword(KwBreak),
        "const"     => Keyword(KwConst),
        "continue"  => Keyword(KwContinue),
        "crate"     => Keyword(KwCrate),
        "do"        => Keyword(KwDo),
        "else"      => Keyword(KwElse),
        "enum"      => Keyword(KwEnum),
        "extern"    => Keyword(KwExtern),
        "false"     => Keyword(KwFalse),
        "final"     => Keyword(KwFinal),
        "fn"        => Keyword(KwFn),
        "for"       => Keyword(KwFor),
        "if"        => Keyword(KwIf),
        "impl"      => Keyword(KwImpl),
        "in"        => Keyword(KwIn),
        "let"       => Keyword(KwLet),
        "loop"      => Keyword(KwLoop),
        "macro"     => Keyword(KwMacro),
        "match"     => Keyword(KwMatch),
        "mod"       => Keyword(KwMod),
        "move"      => Keyword(KwMove),
        "mut"       => Keyword(KwMut),
        "offsetof"  => Keyword(KwOffsetof),
        "override"  => Keyword(KwOverride),
        "priv"      => Keyword(KwPriv),
        "proc"      => Keyword(KwProc),
        "pub"       => Keyword(KwPub),
        "pure"      => Keyword(KwPure),
        "ref"       => Keyword(KwRef),
        "return"    => Keyword(KwReturn),
        "Self"      => Keyword(KwSelfTy),
        "self"      => Keyword(KwSelfVar),
        "sizeof"    => Keyword(KwSizeof),
        "static"    => Keyword(KwStatic),
        "struct"    => Keyword(KwStruct),
        "super"     => Keyword(KwSuper),
        "trait"     => Keyword(KwTrait),
        "true"      => Keyword(KwTrue),
        "type"      => Keyword(KwType),
        "typeof"    => Keyword(KwTypeof),
        "unsafe"    => Keyword(KwUnsafe),
        "unsized"   => Keyword(KwUnsized),
        "use"       => Keyword(KwUse),
        "virtual"   => Keyword(KwVirtual),
        "where"     => Keyword(KwWhere),
        "while"     => Keyword(KwWhile),
        "yield"     => Keyword(KwYield),
    }
}

op_gt       = { ">_", ">" };
op_shr      = ">_" ">";
op_shreq    = ">_" ">_" "=";

symbol: &'static str = {
    op_shreq    => ">>=",
    op_shr      => ">>",

    ","         => ",",
    ";"         => ";",
    "@"         => "@",
    "#"         => "#",
    "$"         => "$",
    "?"         => "?",
    "."         => ".",
    ".."        => "..",
    "..."       => "...",
    ":"         => ":",
    "::"        => "::",
    "!"         => "!",
    "<-"        => "<-",
    "->"        => "->",
    "=>"        => "=>",

    "+"         => "+",
    "-"         => "-",
    "*"         => "*",
    "/"         => "/",
    "%"         => "%",
    "&"         => "&",
    "|"         => "|",
    "^"         => "^",
    "<<"        => "<<",
    "&&"        => "&&",
    "||"        => "||",
    "=="        => "==",
    "!="        => "!=",
    "<"         => "<",
    ">"         => ">",
    "<="        => "<=",
    "="         => "=",
    "+="        => "+=",
    "-="        => "-=",
    "*="        => "*=",
    "/="        => "/=",
    "%="        => "%=",
    "&="        => "&=",
    "|="        => "|=",
    "^="        => "^=",
    "<<="       => "<<=",
};

keyword: KeywordType = {
    "abstract"  => KwAbstract,
    "alignof"   => KwAlignof,
    "as"        => KwAs,
    "become"    => KwBecome,
    "box"       => KwBox,
    "break"     => KwBreak,
    "const"     => KwConst,
    "continue"  => KwContinue,
    "crate"     => KwCrate,
    "do"        => KwDo,
    "else"      => KwElse,
    "enum"      => KwEnum,
    "extern"    => KwExtern,
    "false"     => KwFalse,
    "final"     => KwFinal,
    "fn"        => KwFn,
    "for"       => KwFor,
    "if"        => KwIf,
    "impl"      => KwImpl,
    "in"        => KwIn,
    "let"       => KwLet,
    "loop"      => KwLoop,
    "macro"     => KwMacro,
    "match"     => KwMatch,
    "mod"       => KwMod,
    "move"      => KwMove,
    "mut"       => KwMut,
    "offsetof"  => KwOffsetof,
    "override"  => KwOverride,
    "priv"      => KwPriv,
    "proc"      => KwProc,
    "pub"       => KwPub,
    "pure"      => KwPure,
    "ref"       => KwRef,
    "return"    => KwReturn,
    "Self"      => KwSelfTy,
    "self"      => KwSelfVar,
    "sizeof"    => KwSizeof,
    "static"    => KwStatic,
    "struct"    => KwStruct,
    "super"     => KwSuper,
    "trait"     => KwTrait,
    "true"      => KwTrue,
    "type"      => KwType,
    "typeof"    => KwTypeof,
    "unsafe"    => KwUnsafe,
    "unsized"   => KwUnsized,
    "use"       => KwUse,
    "virtual"   => KwVirtual,
    "where"     => KwWhere,
    "while"     => KwWhile,
    "yield"     => KwYield,
};

// Macros
// Something separated by `D`. Tail `D` is acceptable.
tuple_of_delim<T, D>: Vec<T> = {
    <v:(<T> D)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
tuple_of<T>: Vec<T> = tuple_of_delim<T, ",">;

// Token tree
pub tts: Vec<Token<'input>> = tt*;

pub tt: Token<'input> = {
    "(" <tts> ")"   => Token::Delimited(Delimiter::Paren, <>),
    "[" <tts> "]"   => Token::Delimited(Delimiter::Bracket, <>),
    "{" <tts> "}"   => Token::Delimited(Delimiter::Brace, <>),
    keyword         => Token::Keyword(<>),
    IDENT           => Token::Ident(<>),
    LIFETIME        => Token::Lifetime(<>),
    symbol          => Token::Symbol(<>),
    LITERAL         => Token::Literal(<>),
    INNERDOC        => Token::InnerDoc(<>),
    OUTERDOC        => Token::OuterDoc(<>),
};

// Attributes
inner_attr: Attr<'input> = {
    "#" "!" "[" <attr_content> "]",
    INNERDOC    => Attr::Value{
        key: "doc",
        value: Lit::StrLike{
            is_bytestr: false,
            s: <>.into(),
        }
    },
};
outer_attr: Attr<'input> = {
    "#" "[" <attr_content> "]",
    OUTERDOC    => Attr::Value{
        key: "doc",
        value: Lit::StrLike{
            is_bytestr: false,
            s: <>.into(),
        }
    },
};
attr_content: Attr<'input> = {
    IDENT                                    => Attr::Flag(<>),
    <k: IDENT> "=" <v: LITERAL>              => Attr::Value{ key: k, value: v },
    <IDENT> "(" <tuple_of<attr_content>> ")" => Attr::Sub(<>),
};

// Qualified identifier
QIDENT: Path<'input> =
    <root: "::"?> <comps: (<path_comp> "::")*> <last: path_comp>
        => {
            let mut comps = comps;
            comps.push(last);
            Path{ is_absolute: root.is_some(), comps }
        };
#[inline]
path_comp: PathComp<'input> =
    <body: IDENT> <hint: ("::" "<" <tuple_of<ty>> ">")?>
        => PathComp{ body, hint };

// Module
pub module: ModInner<'input> =
    <attrs: inner_attr*> <items: item*> => ModInner{ attrs, items };

// Item
pub item: Item<'input> =
    <attrs: outer_attr*> <pub_tag: "pub"?> <detail: item_detail>
        => Item{ is_pub: pub_tag.is_some(), attrs, detail };
item_detail: ItemKind<'input> = {
    // https://doc.rust-lang.org/reference/items.html#items
    "extern" "crate" <IDENT> ";"
        => ItemKind::ExternCrate(<>),
    "use" <root: "::"?> <comps: use_comp*> <names: use_names> ";"
        => {
            let path = Path{ is_absolute: root.is_some(), comps };
            match names {
                None        => ItemKind::UseAll(path),
                Some(names) => ItemKind::UseSome{ path, names },
            }
        },
    "mod" <IDENT> ";"
        => ItemKind::Mod{ name: <>, items: None },
    "mod" <name: IDENT> "{" <inner: module> "}"
        => ItemKind::Mod{ name, items: Some(inner.items) }, // TODO: inner doc
    "fn" <sig: fn_sig> <body: fn_body> // TODO: function inner
        => ItemKind::Func{ sig, body },
    "extern" <abi: IDENT?> "{" <decls: extern_decl*> "}"
        => ItemKind::Extern{ abi, decls },
    "type" <alias: IDENT> <opt_templ: template> <whs: where_clause> "=" <origin: ty> ";"
        => ItemKind::Type{ alias, templ: merge_templ(opt_templ, whs), origin },
    "struct" <name: IDENT> <opt_templ: template> <whs: where_clause> ";"
        => ItemKind::StructUnit{ name, templ: merge_templ(opt_templ, whs) },
    "struct" <name: IDENT> <opt_templ: template> "(" <elems: tuple_of<struct_tuple_elem>> ")"
             <whs: where_clause> ";"
        => ItemKind::StructTuple{ name, templ: merge_templ(opt_templ, whs), elems },
    "struct" <name: IDENT> <opt_templ: template> <whs: where_clause>
             "{" <fields: tuple_of<struct_field>> "}"
        => ItemKind::StructNormal{ name, templ: merge_templ(opt_templ, whs), fields },
    "enum" <name: IDENT> <opt_templ: template> <whs: where_clause>
           "{" <vars: tuple_of<enum_var>> "}"
        => ItemKind::Enum{ name, templ: merge_templ(opt_templ, whs), vars },
    // TODO: const
    // TODO: static
    "trait" <name: IDENT> <opt_templ: template> <whs: where_clause>
            "{" <items: trait_item*> "}"
        => ItemKind::Trait{ name, templ: merge_templ(opt_templ, whs), items },
    "impl" <opt_templ: template> <ty_for: ty> <whs: where_clause>
           "{" <items: impl_item*> "}"
        => ItemKind::ImplType{ templ: merge_templ(opt_templ, whs), ty_for, items },
    "impl" <opt_templ: template> <tr_name: trait_name> "for" <ty_for: ty> <whs: where_clause>
           "{" <items: impl_item*> "}"
        => ItemKind::ImplTrait{ templ: merge_templ(opt_templ, whs), tr_name, ty_for, items },
};
use_comp: PathComp<'input> = {
    "self" "::"
        => PathComp{ body: "self", hint: None },
    "super" "::"
        => PathComp{ body: "super", hint: None },
    <IDENT> "::"
        => PathComp{ body: <>, hint: None },
};
use_names: Option<Vec<UseName<'input>>> = {
    "*"                          => None,
    IDENT                        => Some(vec![UseName{ name: <>, alias: None }]),
    "{" <tuple_of<use_name>> "}" => Some(<>),
};
use_name: UseName<'input> = {
    "self" <alias: ("as" <IDENT>)?>
        => UseName{ name: "self", alias },
    <name: IDENT> <alias: ("as" <IDENT>)?>
        => UseName{ name, alias },
};
extern_decl: ExternFuncDecl<'input> =
    <attrs: outer_attr*> <pub_tag: "pub"?> "fn" <sig: fn_sig> ";"
        => ExternFuncDecl{ sig, is_pub: pub_tag.is_some(), attrs };
struct_tuple_elem: StructTupleElem<'input> =
    <attrs: outer_attr*> <pub_tag: "pub"?> <ty: ty>
        => StructTupleElem{ is_pub: pub_tag.is_some(), attrs, ty };
struct_field: StructField<'input> =
    <attrs: outer_attr*> <pub_tag: "pub"?> <name: IDENT> ":" <ty: ty>
        => StructField{ name, is_pub: pub_tag.is_some(), attrs, ty };
#[inline]
enum_var: EnumVar<'input> = {
    <attrs: outer_attr*> <name: IDENT>
        => EnumVar::Unit{ name, attrs },
    <attrs: outer_attr*> <name: IDENT> "(" <elems: tuple_of<struct_tuple_elem>> ")"
        => EnumVar::Tuple{ name, attrs, elems },
    <attrs: outer_attr*> <name: IDENT> "{" <fields: tuple_of<struct_field>> "}"
        => EnumVar::Struct{ name, attrs, fields },
};
#[inline]
trait_item: TraitItem<'input> = {
    <attrs: outer_attr*> "type" <tyb: ty_opt_trait_bound> <default: ("=" <ty>)?> ";"
        => TraitItem::Type{ name: tyb.0, attrs, trait_bounds: (tyb.1).1, default },
    <attrs: outer_attr*> "fn" <sig: fn_sig> ";"
        => TraitItem::Func{ sig, attrs, default: None },
    <attrs: outer_attr*> "fn" <sig: fn_sig> <body: fn_body>
        => TraitItem::Func{ sig, attrs, default: Some(body) },
};
#[inline]
impl_item: ImplItem<'input> = {
    <attrs: outer_attr*> "type" <name: IDENT> "=" <val: ty> ";"
        => ImplItem::Type{ name, attrs, val },
    <attrs: outer_attr*> "fn" <sig: fn_sig> <body: fn_body>
        => ImplItem::Func{ sig, attrs, body },
};

// Template & Where clause
#[inline]
template: Template<'input> = {
        => Template{ lifetimes: vec![], tys: vec![], trait_bounds: vec![] },
    "<" <tuple_of<LIFETIME>> op_gt
        => Template{ lifetimes: <>, tys: vec![], trait_bounds: vec![] },
    "<" <lifetimes: (<LIFETIME> ",")*>
        <trs: (<ty_opt_trait_bound> ",")*> <last: ty_opt_trait_bound> op_gt
        => {
            let mut trs = trs;
            trs.push(last);
            let (tys, trait_bounds) = trs.drain(..).unzip();
            Template{ lifetimes, tys, trait_bounds }
        },
};
ty_opt_trait_bound: (&'input str, TraitBound<'input>) =
    <name: IDENT> <opt_trs: (":" <tuple_of_delim<trait_name, "+">>)?>
        => (name, TraitBound(Ty::from_name(name), opt_trs.unwrap_or(vec![])));
trait_bound: TraitBound<'input> =
    <ty> ":" <tuple_of_delim<trait_name, "+">>
        => TraitBound(<>);
#[inline]
where_clause: Vec<TraitBound<'input>> =
    <("where" <tuple_of<trait_bound>>)?>
        => <>.unwrap_or(vec![]);

// Type & Trait name
pub ty: Ty<'input> = {
    "!" => Ty::Diverging,
    <apply: trait_name> // aka. `TyApply`
        => if is_placeholder(&apply.name) { Ty::Hole }
           else { Ty::Apply(apply) },
    "(" <tuple_of<ty>> ")"
        => Ty::Tuple(<>),
    "fn" "(" <args: tuple_of<ty>> ")" <ret: ("->" <ty>)?>
        => Ty::Func{ args, ret: Box::new(ret.unwrap_or_else(Ty::unit)) },
    "&" <lifetime: LIFETIME?> <mut_tag: "mut"?> <ty: ty>
        => Ty::Ref{ is_mut: mut_tag.is_some(), lifetime, inner: Box::new(ty) },
    "*" <mut_tag: "mut"?> <ty: ty>
        => Ty::Ptr{ is_mut: mut_tag.is_some(), inner: Box::new(ty) },
};
trait_name: TraitName<'input> = {
    <name: QIDENT>
        => TraitName{ name, lifetimes: vec![], params: vec![] },
    <name: QIDENT> "<" <lifetimes: tuple_of<LIFETIME>> op_gt
        => TraitName{ name, lifetimes, params: vec![] },
    <name: QIDENT> "<" <lifetimes: (<LIFETIME> ",")*> <params: (<ty> ",")*> <last: ty> op_gt
        => {
            let mut params = params;
            params.push(last);
            TraitName{ name, lifetimes, params }
        },
};

// Function
fn_sig: FuncSig<'input> =
    <name: IDENT> <opt_templ: template>
    "(" <self_arg: fn_self> <args: tuple_of<fn_arg>> ")"
    <whs: where_clause>
        => FuncSig{ name, templ: merge_templ(opt_templ, whs), self_arg, args };
#[inline]
fn_self: SelfArg = {
        => SelfArg::Static,
    "&" <mut_tag: "mut"?> "self"
        => SelfArg::Ref{ is_mut: mut_tag.is_some() },
    <mut_tag: "mut"?> "self"
        => SelfArg::Consume{ is_mut: mut_tag.is_some() },
};
fn_body: FuncBody<'input> =
    "{" <tts> "}";
fn_arg: FuncArg<'input> = // TODO: pattern matching for arguments
    <name: IDENT> ":" <ty: ty>
        => FuncArg{ name, ty };
