Ok([(Token(Keyword(Extern)), "extern"), (Token(Keyword(Crate)), "crate"), (Token(Ident("mair")), "mair"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Use)), "use"), (Token(Ident("std")), "std"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("fs")), "fs"), (Token(Symbol(ColonColon)), "::"), (Token(Symbol(Mul)), "*"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Use)), "use"), (Token(Ident("std")), "std"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("path")), "path"), (Token(Symbol(ColonColon)), "::"), (Tree { delim: Brace, tts: [(Token(Ident("Path")), "Path"), (Token(Symbol(Comma)), ","), (Token(Ident("PathBuf")), "PathBuf")] }, "{Path, PathBuf}"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Use)), "use"), (Token(Ident("std")), "std"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("io")), "io"), (Token(Symbol(ColonColon)), "::"), (Tree { delim: Brace, tts: [(Token(Keyword(SelfVar)), "self"), (Token(Symbol(Comma)), ","), (Token(Ident("Read")), "Read"), (Token(Symbol(Comma)), ","), (Token(Ident("Write")), "Write")] }, "{self, Read, Write}"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Use)), "use"), (Token(Ident("std")), "std"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("ffi")), "ffi"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("OsStr")), "OsStr"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Use)), "use"), (Token(Ident("mair")), "mair"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("parse")), "parse"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("error")), "error"), (Token(Symbol(ColonColon)), "::"), (Token(Symbol(Mul)), "*"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Use)), "use"), (Token(Ident("mair")), "mair"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("parse")), "parse"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("lexer")), "lexer"), (Token(Symbol(ColonColon)), "::"), (Token(Symbol(Mul)), "*"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Fn)), "fn"), (Token(Ident("test_dir_helper")), "test_dir_helper"), (Token(Symbol(Lt)), "<"), (Token(Ident("P")), "P"), (Token(Symbol(Colon)), ":"), (Token(Ident("AsRef")), "AsRef"), (Token(Symbol(Lt)), "<"), (Token(Ident("Path")), "Path"), (Token(Symbol(Gt)), ">"), (Token(Symbol(Comma)), ","), (Token(Ident("F")), "F"), (Token(Symbol(Colon)), ":"), (Token(Ident("Fn")), "Fn"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Keyword(Mut)), "mut"), (Token(Ident("Write")), "Write"), (Token(Symbol(Comma)), ","), (Token(Symbol(And)), "&"), (Token(Ident("str")), "str")] }, "(&mut Write, &str)"), (Token(Symbol(RArrow)), "->"), (Token(Ident("io")), "io"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("Result")), "Result"), (Token(Symbol(Lt)), "<"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Shr)), ">>"), (Tree { delim: Paren, tts: [(Token(Ident("path")), "path"), (Token(Symbol(Colon)), ":"), (Token(Ident("P")), "P"), (Token(Symbol(Comma)), ","), (Token(Ident("f")), "f"), (Token(Symbol(Colon)), ":"), (Token(Ident("F")), "F"), (Token(Symbol(Comma)), ",")] }, "(\n    path: P,\n    f: F,\n)"), (Token(Symbol(RArrow)), "->"), (Token(Ident("io")), "io"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("Result")), "Result"), (Token(Symbol(Lt)), "<"), (Token(Ident("bool")), "bool"), (Token(Symbol(Gt)), ">"), (Tree { delim: Brace, tts: [(Token(Keyword(Let)), "let"), (Token(Keyword(Mut)), "mut"), (Token(Ident("passed")), "passed"), (Token(Symbol(Eq)), "="), (Token(Literal(Bool(true))), "true"), (Token(Symbol(Semi)), ";"), (Token(Keyword(For)), "for"), (Token(Ident("dirent")), "dirent"), (Token(Keyword(In)), "in"), (Token(Ident("read_dir")), "read_dir"), (Tree { delim: Paren, tts: [(Token(Ident("path")), "path")] }, "(path)"), (Token(Symbol(Question)), "?"), (Tree { delim: Brace, tts: [(Token(Keyword(Let)), "let"), (Token(Ident("pathi")), "pathi"), (Token(Symbol(Eq)), "="), (Token(Ident("dirent")), "dirent"), (Token(Symbol(Question)), "?"), (Token(Symbol(Dot)), "."), (Token(Ident("path")), "path"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";"), (Token(Keyword(If)), "if"), (Token(Ident("pathi")), "pathi"), (Token(Symbol(Dot)), "."), (Token(Ident("extension")), "extension"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(EqEq)), "=="), (Token(Ident("Some")), "Some"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("OsStr")), "OsStr"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "in" })), "\"in\"")] }, "(\"in\")")] }, "(&OsStr::new(\"in\"))"), (Tree { delim: Brace, tts: [(Token(Ident("println")), "println"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "testing {}" })), "\"testing {}\""), (Token(Symbol(Comma)), ","), (Token(Ident("pathi")), "pathi"), (Token(Symbol(Dot)), "."), (Token(Ident("display")), "display"), (Tree { delim: Paren, tts: [] }, "()")] }, "(\"testing {}\", pathi.display())"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Let)), "let"), (Token(Ident("patho")), "patho"), (Token(Symbol(Eq)), "="), (Token(Ident("pathi")), "pathi"), (Token(Symbol(Dot)), "."), (Token(Ident("with_extension")), "with_extension"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "out" })), "\"out\"")] }, "(\"out\")"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Let)), "let"), (Token(Keyword(Mut)), "mut"), (Token(Ident("si")), "si"), (Token(Symbol(Eq)), "="), (Token(Ident("String")), "String"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Let)), "let"), (Token(Keyword(Mut)), "mut"), (Token(Ident("vo")), "vo"), (Token(Symbol(Eq)), "="), (Token(Ident("vec")), "vec"), (Token(Symbol(Bang)), "!"), (Tree { delim: Bracket, tts: [] }, "[]"), (Token(Symbol(Semi)), ";"), (Token(Ident("File")), "File"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("open")), "open"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("pathi")), "pathi")] }, "(&pathi)"), (Token(Symbol(Question)), "?"), (Token(Symbol(Dot)), "."), (Token(Ident("read_to_string")), "read_to_string"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Keyword(Mut)), "mut"), (Token(Ident("si")), "si")] }, "(&mut si)"), (Token(Symbol(Question)), "?"), (Token(Symbol(Semi)), ";"), (Token(Ident("File")), "File"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("open")), "open"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("patho")), "patho")] }, "(&patho)"), (Token(Symbol(Question)), "?"), (Token(Symbol(Dot)), "."), (Token(Ident("read_to_end")), "read_to_end"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Keyword(Mut)), "mut"), (Token(Ident("vo")), "vo")] }, "(&mut vo)"), (Token(Symbol(Question)), "?"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Let)), "let"), (Token(Keyword(Mut)), "mut"), (Token(Ident("buf")), "buf"), (Token(Symbol(Eq)), "="), (Token(Ident("vec")), "vec"), (Token(Symbol(Bang)), "!"), (Tree { delim: Bracket, tts: [] }, "[]"), (Token(Symbol(Semi)), ";"), (Token(Ident("f")), "f"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Keyword(Mut)), "mut"), (Token(Ident("buf")), "buf"), (Token(Symbol(Comma)), ","), (Token(Symbol(And)), "&"), (Token(Ident("si")), "si")] }, "(&mut buf, &si)"), (Token(Symbol(Question)), "?"), (Token(Symbol(Semi)), ";"), (Token(Keyword(If)), "if"), (Token(Ident("vo")), "vo"), (Token(Symbol(EqEq)), "=="), (Token(Ident("buf")), "buf"), (Tree { delim: Brace, tts: [(Token(Ident("println")), "println"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "ok" })), "\"ok\"")] }, "(\"ok\")"), (Token(Symbol(Semi)), ";")] }, "{\n                println!(\"ok\");\n            }"), (Token(Keyword(Else)), "else"), (Tree { delim: Brace, tts: [(Token(Ident("File")), "File"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("create")), "create"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("patho")), "patho")] }, "(&patho)"), (Token(Symbol(Question)), "?"), (Token(Symbol(Dot)), "."), (Token(Ident("write_all")), "write_all"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("buf")), "buf")] }, "(&buf)"), (Token(Symbol(Question)), "?"), (Token(Symbol(Semi)), ";"), (Token(Ident("passed")), "passed"), (Token(Symbol(Eq)), "="), (Token(Literal(Bool(false))), "false"), (Token(Symbol(Semi)), ";"), (Token(Ident("println")), "println"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "fail" })), "\"fail\"")] }, "(\"fail\")"), (Token(Symbol(Semi)), ";")] }, "{\n                File::create(&patho)?\n                    .write_all(&buf)?;\n                passed = false;\n                println!(\"fail\");\n            }")] }, "{\n            println!(\"testing {}\", pathi.display());\n            let patho = pathi.with_extension(\"out\");\n            let mut si = String::new();\n            let mut vo = vec![];\n            File::open(&pathi)?\n                .read_to_string(&mut si)?;\n            File::open(&patho)?\n                .read_to_end(&mut vo)?;\n            let mut buf = vec![];\n            f(&mut buf, &si)?;\n            if vo == buf {\n                println!(\"ok\");\n            } else {\n                File::create(&patho)?\n                    .write_all(&buf)?;\n                passed = false;\n                println!(\"fail\");\n            }\n        }")] }, "{\n        let pathi = dirent?.path();\n        if pathi.extension() == Some(&OsStr::new(\"in\")) {\n            println!(\"testing {}\", pathi.display());\n            let patho = pathi.with_extension(\"out\");\n            let mut si = String::new();\n            let mut vo = vec![];\n            File::open(&pathi)?\n                .read_to_string(&mut si)?;\n            File::open(&patho)?\n                .read_to_end(&mut vo)?;\n            let mut buf = vec![];\n            f(&mut buf, &si)?;\n            if vo == buf {\n                println!(\"ok\");\n            } else {\n                File::create(&patho)?\n                    .write_all(&buf)?;\n                passed = false;\n                println!(\"fail\");\n            }\n        }\n    }"), (Token(Ident("Ok")), "Ok"), (Tree { delim: Paren, tts: [(Token(Ident("passed")), "passed")] }, "(passed)")] }, "{\n    let mut passed = true;\n    for dirent in read_dir(path)? {\n        let pathi = dirent?.path();\n        if pathi.extension() == Some(&OsStr::new(\"in\")) {\n            println!(\"testing {}\", pathi.display());\n            let patho = pathi.with_extension(\"out\");\n            let mut si = String::new();\n            let mut vo = vec![];\n            File::open(&pathi)?\n                .read_to_string(&mut si)?;\n            File::open(&patho)?\n                .read_to_end(&mut vo)?;\n            let mut buf = vec![];\n            f(&mut buf, &si)?;\n            if vo == buf {\n                println!(\"ok\");\n            } else {\n                File::create(&patho)?\n                    .write_all(&buf)?;\n                passed = false;\n                println!(\"fail\");\n            }\n        }\n    }\n    Ok(passed)\n}"), (Token(Keyword(Fn)), "fn"), (Token(Ident("test_dir")), "test_dir"), (Token(Symbol(Lt)), "<"), (Token(Ident("F")), "F"), (Token(Symbol(Colon)), ":"), (Token(Ident("Fn")), "Fn"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Keyword(Mut)), "mut"), (Token(Ident("Write")), "Write"), (Token(Symbol(Comma)), ","), (Token(Symbol(And)), "&"), (Token(Ident("str")), "str")] }, "(&mut Write, &str)"), (Token(Symbol(RArrow)), "->"), (Token(Ident("io")), "io"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("Result")), "Result"), (Token(Symbol(Lt)), "<"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Shr)), ">>"), (Tree { delim: Paren, tts: [(Token(Ident("dir")), "dir"), (Token(Symbol(Colon)), ":"), (Token(Symbol(And)), "&"), (Token(Ident("str")), "str"), (Token(Symbol(Comma)), ","), (Token(Ident("f")), "f"), (Token(Symbol(Colon)), ":"), (Token(Ident("F")), "F")] }, "(dir: &str, f: F)"), (Tree { delim: Brace, tts: [(Token(Keyword(Let)), "let"), (Token(Keyword(Mut)), "mut"), (Token(Ident("path")), "path"), (Token(Symbol(Eq)), "="), (Token(Ident("PathBuf")), "PathBuf"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";"), (Token(Ident("path")), "path"), (Token(Symbol(Dot)), "."), (Token(Ident("push")), "push"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "." })), "\".\"")] }, "(\".\")"), (Token(Symbol(Semi)), ";"), (Token(Ident("path")), "path"), (Token(Symbol(Dot)), "."), (Token(Ident("push")), "push"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "tests" })), "\"tests\"")] }, "(\"tests\")"), (Token(Symbol(Semi)), ";"), (Token(Ident("path")), "path"), (Token(Symbol(Dot)), "."), (Token(Ident("push")), "push"), (Tree { delim: Paren, tts: [(Token(Ident("dir")), "dir")] }, "(dir)"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Match)), "match"), (Token(Ident("test_dir_helper")), "test_dir_helper"), (Tree { delim: Paren, tts: [(Token(Ident("path")), "path"), (Token(Symbol(Comma)), ","), (Token(Ident("f")), "f")] }, "(path, f)"), (Tree { delim: Brace, tts: [(Token(Ident("Err")), "Err"), (Tree { delim: Paren, tts: [(Token(Ident("e")), "e")] }, "(e)"), (Token(Symbol(RFatArrow)), "=>"), (Token(Ident("panic")), "panic"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "os error: {:?}" })), "\"os error: {:?}\""), (Token(Symbol(Comma)), ","), (Token(Ident("e")), "e")] }, "(\"os error: {:?}\", e)"), (Token(Symbol(Comma)), ","), (Token(Ident("Ok")), "Ok"), (Tree { delim: Paren, tts: [(Token(Literal(Bool(false))), "false")] }, "(false)"), (Token(Symbol(RFatArrow)), "=>"), (Token(Ident("panic")), "panic"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "test fail" })), "\"test fail\"")] }, "(\"test fail\")"), (Token(Symbol(Comma)), ","), (Token(Ident("Ok")), "Ok"), (Tree { delim: Paren, tts: [(Token(Literal(Bool(true))), "true")] }, "(true)"), (Token(Symbol(RFatArrow)), "=>"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Comma)), ",")] }, "{\n        Err(e) => panic!(\"os error: {:?}\", e),\n        Ok(false) => panic!(\"test fail\"),\n        Ok(true) => (),\n    }")] }, "{\n    let mut path = PathBuf::new();\n    path.push(\".\");\n    path.push(\"tests\");\n    path.push(dir);\n    match test_dir_helper(path, f) {\n        Err(e) => panic!(\"os error: {:?}\", e),\n        Ok(false) => panic!(\"test fail\"),\n        Ok(true) => (),\n    }\n}"), (Token(Keyword(Fn)), "fn"), (Token(Ident("test_dir_lines")), "test_dir_lines"), (Token(Symbol(Lt)), "<"), (Token(Ident("F")), "F"), (Token(Symbol(Colon)), ":"), (Token(Ident("Fn")), "Fn"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Keyword(Mut)), "mut"), (Token(Ident("Write")), "Write"), (Token(Symbol(Comma)), ","), (Token(Symbol(And)), "&"), (Token(Ident("str")), "str")] }, "(&mut Write, &str)"), (Token(Symbol(RArrow)), "->"), (Token(Ident("io")), "io"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("Result")), "Result"), (Token(Symbol(Lt)), "<"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Shr)), ">>"), (Tree { delim: Paren, tts: [(Token(Ident("dir")), "dir"), (Token(Symbol(Colon)), ":"), (Token(Symbol(And)), "&"), (Token(Ident("str")), "str"), (Token(Symbol(Comma)), ","), (Token(Ident("f")), "f"), (Token(Symbol(Colon)), ":"), (Token(Ident("F")), "F")] }, "(dir: &str, f: F)"), (Tree { delim: Brace, tts: [(Token(Ident("test_dir")), "test_dir"), (Tree { delim: Paren, tts: [(Token(Ident("dir")), "dir"), (Token(Symbol(Comma)), ","), (Token(Symbol(Or)), "|"), (Token(Keyword(Mut)), "mut"), (Token(Ident("fo")), "fo"), (Token(Symbol(Comma)), ","), (Token(Ident("s")), "s"), (Token(Symbol(Or)), "|"), (Tree { delim: Brace, tts: [(Token(Keyword(For)), "for"), (Tree { delim: Paren, tts: [(Token(Ident("i")), "i"), (Token(Symbol(Comma)), ","), (Token(Ident("line")), "line")] }, "(i, line)"), (Token(Keyword(In)), "in"), (Token(Ident("s")), "s"), (Token(Symbol(Dot)), "."), (Token(Ident("lines")), "lines"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Dot)), "."), (Token(Ident("enumerate")), "enumerate"), (Tree { delim: Paren, tts: [] }, "()"), (Tree { delim: Brace, tts: [(Token(Ident("print")), "print"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "#{} " })), "\"#{} \""), (Token(Symbol(Comma)), ","), (Token(Ident("i")), "i"), (Token(Symbol(Add)), "+"), (Token(Literal(IntLike { ty: None, val: 1 })), "1")] }, "(\"#{} \", i + 1)"), (Token(Symbol(Semi)), ";"), (Token(Ident("f")), "f"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Keyword(Mut)), "mut"), (Token(Ident("fo")), "fo"), (Token(Symbol(Comma)), ","), (Token(Ident("line")), "line")] }, "(&mut fo, line)"), (Token(Symbol(Question)), "?")] }, "{\n            print!(\"#{} \", i + 1);\n            f(&mut fo, line)?\n        }"), (Token(Ident("println")), "println"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "" })), "\"\"")] }, "(\"\")"), (Token(Symbol(Semi)), ";"), (Token(Ident("Ok")), "Ok"), (Tree { delim: Paren, tts: [(Tree { delim: Paren, tts: [] }, "()")] }, "(())")] }, "{\n        for (i, line) in s.lines().enumerate() {\n            print!(\"#{} \", i + 1);\n            f(&mut fo, line)?\n        }\n        println!(\"\");\n        Ok(())\n    }")] }, "(dir, |mut fo, s| {\n        for (i, line) in s.lines().enumerate() {\n            print!(\"#{} \", i + 1);\n            f(&mut fo, line)?\n        }\n        println!(\"\");\n        Ok(())\n    })"), (Token(Symbol(Semi)), ";")] }, "{\n    test_dir(dir, |mut fo, s| {\n        for (i, line) in s.lines().enumerate() {\n            print!(\"#{} \", i + 1);\n            f(&mut fo, line)?\n        }\n        println!(\"\");\n        Ok(())\n    });\n}"), (Token(Keyword(Fn)), "fn"), (Token(Ident("lex")), "lex"), (Tree { delim: Paren, tts: [(Token(Ident("input")), "input"), (Token(Symbol(Colon)), ":"), (Token(Symbol(And)), "&"), (Token(Ident("str")), "str")] }, "(input: &str)"), (Token(Symbol(RArrow)), "->"), (Token(Ident("Result")), "Result"), (Token(Symbol(Lt)), "<"), (Token(Ident("Vec")), "Vec"), (Token(Symbol(Lt)), "<"), (Token(Ident("Token")), "Token"), (Token(Symbol(Gt)), ">"), (Token(Symbol(Comma)), ","), (Token(Ident("LexicalError")), "LexicalError"), (Token(Symbol(Lt)), "<"), (Token(Ident("usize")), "usize"), (Token(Symbol(Shr)), ">>"), (Tree { delim: Brace, tts: [(Token(Keyword(Let)), "let"), (Token(Keyword(Mut)), "mut"), (Token(Ident("v")), "v"), (Token(Symbol(Eq)), "="), (Token(Ident("vec")), "vec"), (Token(Symbol(Bang)), "!"), (Tree { delim: Bracket, tts: [] }, "[]"), (Token(Symbol(Semi)), ";"), (Token(Keyword(For)), "for"), (Token(Ident("c")), "c"), (Token(Keyword(In)), "in"), (Token(Ident("Lexer")), "Lexer"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Ident("input")), "input")] }, "(input)"), (Tree { delim: Brace, tts: [(Token(Ident("v")), "v"), (Token(Symbol(Dot)), "."), (Token(Ident("push")), "push"), (Tree { delim: Paren, tts: [(Token(Ident("c")), "c"), (Token(Symbol(Question)), "?")] }, "(c?)"), (Token(Symbol(Semi)), ";")] }, "{\n        v.push(c?);\n    }"), (Token(Ident("Ok")), "Ok"), (Tree { delim: Paren, tts: [(Token(Ident("v")), "v")] }, "(v)")] }, "{\n    let mut v = vec![];\n    for c in Lexer::new(input) {\n        v.push(c?);\n    }\n    Ok(v)\n}"), (Token(Keyword(Fn)), "fn"), (Token(Ident("tts")), "tts"), (Tree { delim: Paren, tts: [(Token(Ident("input")), "input"), (Token(Symbol(Colon)), ":"), (Token(Symbol(And)), "&"), (Token(Ident("str")), "str")] }, "(input: &str)"), (Token(Symbol(RArrow)), "->"), (Token(Ident("Result")), "Result"), (Token(Symbol(Lt)), "<"), (Token(Ident("Vec")), "Vec"), (Token(Symbol(Lt)), "<"), (Token(Ident("TT")), "TT"), (Token(Symbol(Gt)), ">"), (Token(Symbol(Comma)), ","), (Token(Ident("UnmatchedDelimError")), "UnmatchedDelimError"), (Token(Symbol(Gt)), ">"), (Tree { delim: Brace, tts: [(Token(Keyword(Let)), "let"), (Token(Ident("ltoks")), "ltoks"), (Token(Symbol(Eq)), "="), (Token(Ident("lex")), "lex"), (Tree { delim: Paren, tts: [(Token(Ident("input")), "input")] }, "(input)"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";"), (Token(Ident("parse_tts")), "parse_tts"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("ltoks")), "ltoks")] }, "(&ltoks)")] }, "{\n    let ltoks = lex(input).unwrap();\n    parse_tts(&ltoks)\n}"), (Token(Symbol(Hash)), "#"), (Tree { delim: Bracket, tts: [(Token(Ident("test")), "test")] }, "[test]"), (Token(Keyword(Fn)), "fn"), (Token(Ident("parse_test")), "parse_test"), (Tree { delim: Paren, tts: [] }, "()"), (Tree { delim: Brace, tts: [(Token(Ident("test_dir_lines")), "test_dir_lines"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "lexer_unit" })), "\"lexer_unit\""), (Token(Symbol(Comma)), ","), (Token(Symbol(Or)), "|"), (Token(Ident("f")), "f"), (Token(Symbol(Comma)), ","), (Token(Ident("s")), "s"), (Token(Symbol(Or)), "|"), (Tree { delim: Brace, tts: [(Token(Ident("writeln")), "writeln"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Ident("f")), "f"), (Token(Symbol(Comma)), ","), (Token(Literal(StrLike { is_bytestr: false, s: "{:?}" })), "\"{:?}\""), (Token(Symbol(Comma)), ","), (Token(Ident("lex")), "lex"), (Tree { delim: Paren, tts: [(Token(Ident("s")), "s")] }, "(s)")] }, "(f, \"{:?}\", lex(s))")] }, "{\n        writeln!(f, \"{:?}\", lex(s))\n    }")] }, "(\"lexer_unit\", |f, s| {\n        writeln!(f, \"{:?}\", lex(s))\n    })"), (Token(Symbol(Semi)), ";"), (Token(Ident("test_dir")), "test_dir"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "lexer_large" })), "\"lexer_large\""), (Token(Symbol(Comma)), ","), (Token(Symbol(Or)), "|"), (Token(Ident("f")), "f"), (Token(Symbol(Comma)), ","), (Token(Ident("s")), "s"), (Token(Symbol(Or)), "|"), (Tree { delim: Brace, tts: [(Token(Ident("writeln")), "writeln"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Ident("f")), "f"), (Token(Symbol(Comma)), ","), (Token(Literal(StrLike { is_bytestr: false, s: "{:?}" })), "\"{:?}\""), (Token(Symbol(Comma)), ","), (Token(Ident("lex")), "lex"), (Tree { delim: Paren, tts: [(Token(Ident("s")), "s")] }, "(s)")] }, "(f, \"{:?}\", lex(s))")] }, "{\n        writeln!(f, \"{:?}\", lex(s))\n    }")] }, "(\"lexer_large\", |f, s| {\n        writeln!(f, \"{:?}\", lex(s))\n    })"), (Token(Symbol(Semi)), ";"), (Token(Ident("test_dir")), "test_dir"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "tts_simple" })), "\"tts_simple\""), (Token(Symbol(Comma)), ","), (Token(Symbol(Or)), "|"), (Token(Ident("f")), "f"), (Token(Symbol(Comma)), ","), (Token(Ident("s")), "s"), (Token(Symbol(Or)), "|"), (Tree { delim: Brace, tts: [(Token(Ident("writeln")), "writeln"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Ident("f")), "f"), (Token(Symbol(Comma)), ","), (Token(Literal(StrLike { is_bytestr: false, s: "{:?}" })), "\"{:?}\""), (Token(Symbol(Comma)), ","), (Token(Ident("tts")), "tts"), (Tree { delim: Paren, tts: [(Token(Ident("s")), "s")] }, "(s)")] }, "(f, \"{:?}\", tts(s))")] }, "{\n        writeln!(f, \"{:?}\", tts(s))\n    }")] }, "(\"tts_simple\", |f, s| {\n        writeln!(f, \"{:?}\", tts(s))\n    })"), (Token(Symbol(Semi)), ";"), (Token(Ident("test_dir")), "test_dir"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "tts_large" })), "\"tts_large\""), (Token(Symbol(Comma)), ","), (Token(Symbol(Or)), "|"), (Token(Ident("f")), "f"), (Token(Symbol(Comma)), ","), (Token(Ident("s")), "s"), (Token(Symbol(Or)), "|"), (Tree { delim: Brace, tts: [(Token(Ident("writeln")), "writeln"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Ident("f")), "f"), (Token(Symbol(Comma)), ","), (Token(Literal(StrLike { is_bytestr: false, s: "{:?}" })), "\"{:?}\""), (Token(Symbol(Comma)), ","), (Token(Ident("tts")), "tts"), (Tree { delim: Paren, tts: [(Token(Ident("s")), "s")] }, "(s)")] }, "(f, \"{:?}\", tts(s))")] }, "{\n        writeln!(f, \"{:?}\", tts(s))\n    }")] }, "(\"tts_large\", |f, s| {\n        writeln!(f, \"{:?}\", tts(s))\n    })"), (Token(Symbol(Semi)), ";")] }, "{\n    test_dir_lines(\"lexer_unit\", |f, s| {\n        writeln!(f, \"{:?}\", lex(s))\n    });\n    test_dir(\"lexer_large\", |f, s| {\n        writeln!(f, \"{:?}\", lex(s))\n    });\n    test_dir(\"tts_simple\", |f, s| {\n        writeln!(f, \"{:?}\", tts(s))\n    });\n    test_dir(\"tts_large\", |f, s| {\n        writeln!(f, \"{:?}\", tts(s))\n    });\n}")])
