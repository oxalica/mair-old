Mod { attrs: [Doc { loc: "//! This test example is partial copied from `src/mair/parse/lexer.rs`\n", doc: " This test example is partial copied from `src/mair/parse/lexer.rs`\n" }], items: [ItemWrap { attrs: [Doc { loc: "/// The regex match a char(maybe escaped).\n", doc: " The regex match a char(maybe escaped).\n" }], is_pub: false, detail: Const { name: Ok("RESTR_CHAR"), ty: Ref { lt: Some("static"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) }, val: Literal(StrLike { is_bytestr: false, s: "(?x:\n    (?P<char_normal>[[:^cntrl:]&&[^\\\\]])|\n    \\\\(?:\n        (?P<char_escape_simple>[\\\\\'\"nrt0\\n])|\n        x(?P<char_escape_ascii>[[:xdigit:]]{2})|\n        u\\{(?P<char_escape_unicode>[[:xdigit:]]{1,6})\\}\n    )\n)" }) } }, ItemWrap { attrs: [], is_pub: false, detail: Const { name: Ok("RESTR_NUM"), ty: Ref { lt: Some("static"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) }, val: Literal(StrLike { is_bytestr: false, s: "(?x:\n    (?:\n        0b(?P<num_bin>[01_]+)|\n        0o(?P<num_oct>[0-7_]+)|\n        0x(?P<num_hex>[[:xdigit:]]+)|\n        (?P<num_body>\n            \\d[\\d_]*\n            (?P<num_float_like>\n                (?:\\.\\d[\\d_]*)?\n                (?:[Ee][+-]?_*\\d[_\\d]*)?\n            )\n        )\n    )\n    (?P<num_suffix>\\w*)\n)" }) } }, ItemWrap { attrs: [], is_pub: false, detail: PluginInvoke(PluginInvoke { name: Ok("lazy_static"), ident: None, tt: (Tree { delim: Brace, tts: [(Token(Keyword(Static)), "static"), (Token(Keyword(Ref)), "ref"), (Token(Ident("RE_MAIN")), "RE_MAIN"), (Token(Symbol(Colon)), ":"), (Token(Ident("Regex")), "Regex"), (Token(Symbol(Eq)), "="), (Token(Ident("Regex")), "Regex"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("format")), "format"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )" })), "r#\"(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )\"#"), (Token(Symbol(Comma)), ","), (Token(Ident("num")), "num"), (Token(Symbol(Eq)), "="), (Token(Ident("RESTR_NUM")), "RESTR_NUM"), (Token(Symbol(Comma)), ","), (Token(Ident("chr")), "chr"), (Token(Symbol(Eq)), "="), (Token(Ident("RESTR_CHAR")), "RESTR_CHAR"), (Token(Symbol(Comma)), ","), (Token(Ident("symbols")), "symbols"), (Token(Symbol(Eq)), "="), (Token(Symbol(Mul)), "*"), (Token(Ident("RESTR_SYMBOLS")), "RESTR_SYMBOLS"), (Token(Symbol(Comma)), ","), (Token(Ident("keywords")), "keywords"), (Token(Symbol(Eq)), "="), (Token(Symbol(Mul)), "*"), (Token(Ident("RESTR_KEYWORDS")), "RESTR_KEYWORDS")] }, "(r#\"(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )\"#, num=RESTR_NUM, chr=RESTR_CHAR, symbols=*RESTR_SYMBOLS, keywords=*RESTR_KEYWORDS\n    )")] }, "(&format!(r#\"(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )\"#, num=RESTR_NUM, chr=RESTR_CHAR, symbols=*RESTR_SYMBOLS, keywords=*RESTR_KEYWORDS\n    ))"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Static)), "static"), (Token(Keyword(Ref)), "ref"), (Token(Ident("RE_BLOCK_COMMENT_BEGIN_END")), "RE_BLOCK_COMMENT_BEGIN_END"), (Token(Symbol(Colon)), ":"), (Token(Ident("Regex")), "Regex"), (Token(Symbol(Eq)), "="), (Token(Ident("Regex")), "Regex"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "(?s).*?(?:(?P<begin>/\\*)|\\*/)" })), "r\"(?s).*?(?:(?P<begin>/\\*)|\\*/)\""), (Token(Symbol(Comma)), ",")] }, "(\n        r\"(?s).*?(?:(?P<begin>/\\*)|\\*/)\",\n    )"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Static)), "static"), (Token(Keyword(Ref)), "ref"), (Token(Ident("RE_NUM_SUFFIX")), "RE_NUM_SUFFIX"), (Token(Symbol(Colon)), ":"), (Token(Ident("Regex")), "Regex"), (Token(Symbol(Eq)), "="), (Token(Ident("Regex")), "Regex"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "(?x)\\A(?:\n            (?P<int_like>[iu](?:8|16|32|64|size))|\n            f(?:32|64)\n        )?\\z" })), "r\"(?x)\\A(?:\n            (?P<int_like>[iu](?:8|16|32|64|size))|\n            f(?:32|64)\n        )?\\z\"")] }, "(\n        r\"(?x)\\A(?:\n            (?P<int_like>[iu](?:8|16|32|64|size))|\n            f(?:32|64)\n        )?\\z\"\n    )"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";")] }, "{\n    static ref RE_MAIN: Regex = Regex::new(&format!(r#\"(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )\"#, num=RESTR_NUM, chr=RESTR_CHAR, symbols=*RESTR_SYMBOLS, keywords=*RESTR_KEYWORDS\n    )).unwrap();\n\n    static ref RE_BLOCK_COMMENT_BEGIN_END: Regex = Regex::new(\n        r\"(?s).*?(?:(?P<begin>/\\*)|\\*/)\",\n    ).unwrap();\n\n    static ref RE_NUM_SUFFIX: Regex = Regex::new(\n        r\"(?x)\\A(?:\n            (?P<int_like>[iu](?:8|16|32|64|size))|\n            f(?:32|64)\n        )?\\z\"\n    ).unwrap();\n}") }) }, ItemWrap { attrs: [], is_pub: false, detail: ImplType { templ: [Lifetime { name: "a", bound: None }], ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }] }, args: [Lifetime("a")] }), whs: None, items: [ItemWrap { attrs: [], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("new"), templ: [], args: [Bind { pat: BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }, ty: Ref { lt: Some("a"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) } }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [SelfTy_("Self")] }, args: [] })), whs: None }, body: Block { attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })] }) } } }] } }, ItemWrap { attrs: [], is_pub: false, detail: ImplTrait { templ: [Lifetime { name: "a", bound: None }], tr: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Iterator"), hint: None }] }, args: [] }), ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }] }, args: [Lifetime("a")] }), whs: None, items: [ItemWrap { attrs: [], is_pub: false, detail: AssocTy { name: Ok("Item"), val: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("char"), hint: None }] }, args: [] })), Ty(Ref { lt: Some("a"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) })] }) } }, ItemWrap { attrs: [], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("next"), templ: [], args: [SelfRef { is_mut: true }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Option"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [SelfTy_("Self"), Name { name: Ok("Item"), hint: None }] }, args: [] }))] })), whs: None }, body: Block { attrs: [], stmts: [PluginInvoke(PluginInvoke { name: Ok("lazy_static"), ident: None, tt: (Tree { delim: Brace, tts: [(Token(Keyword(Static)), "static"), (Token(Keyword(Ref)), "ref"), (Token(Ident("RE_ESCAPED")), "RE_ESCAPED"), (Token(Symbol(Colon)), ":"), (Token(Ident("Regex")), "Regex"), (Token(Symbol(Eq)), "="), (Token(Ident("Regex")), "Regex"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("format")), "format"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "\\A{}" })), "r\"\\A{}\""), (Token(Symbol(Comma)), ","), (Token(Ident("RESTR_CHAR")), "RESTR_CHAR")] }, "(r\"\\A{}\", RESTR_CHAR)")] }, "(\n                &format!(r\"\\A{}\", RESTR_CHAR)\n            )"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";")] }, "{\n            static ref RE_ESCAPED: Regex = Regex::new(\n                &format!(r\"\\A{}\", RESTR_CHAR)\n            ).unwrap();\n        }") }), Let { pat: BindLike { name: Ok("err"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }] }] } }], ret: Some(Loop { label: None, body: Block { attrs: [], stmts: [], ret: Some(Return { kw_loc: "return", expr: Some(If { cond: MemberCall { obj: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, func: Name { name: Ok("is_empty"), hint: None }, par_loc: "(", args: [] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }, else_expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("cap"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("RE_ESCAPED"), hint: None }] }), func: Name { name: Ok("captures"), hint: None }, par_loc: "(", args: [TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }] }, then_expr: Block { attrs: [], stmts: [Expr(BinaryOp { op: Assign, op_loc: "=", l: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, r: UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }) }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }, r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) } } } })], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_normal" })] }, then_expr: Block { attrs: [], stmts: [], ret: Some(MemberCall { obj: MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("chars"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("next"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }) }, else_expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_escape_simple" })] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Index { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_bytes"), hint: None }, par_loc: "(", args: [] }, brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }) }, arms: [MatchArm { pats: [Literal(CharLike { is_byte: true, ch: 'n' })], cond: None, expr: Literal(CharLike { is_byte: false, ch: '\n' }) }, MatchArm { pats: [Literal(CharLike { is_byte: true, ch: 'r' })], cond: None, expr: Literal(CharLike { is_byte: false, ch: '\r' }) }, MatchArm { pats: [Literal(CharLike { is_byte: true, ch: 't' })], cond: None, expr: Literal(CharLike { is_byte: false, ch: '\t' }) }, MatchArm { pats: [Literal(CharLike { is_byte: true, ch: '0' })], cond: None, expr: Literal(CharLike { is_byte: false, ch: '\u{0}' }) }, MatchArm { pats: [Literal(CharLike { is_byte: true, ch: '\n' })], cond: None, expr: Block { attrs: [], stmts: [Expr(BinaryOp { op: Assign, op_loc: "=", l: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, r: MemberCall { obj: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, func: Name { name: Ok("trim_left"), hint: None }, par_loc: "(", args: [] } })], ret: Some(Continue { label: None, kw_loc: "continue" }) } }, MatchArm { pats: [BindLike { name: Ok("c"), is_ref: false, is_mut: false, pat: None }], cond: Some(MemberCall { obj: Literal(StrLike { is_bytestr: true, s: "\\\\\'\"nrt0" }), func: Name { name: Ok("contains"), hint: None }, par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("c"), hint: None }] }) }] }), expr: As { expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("c"), hint: None }] }), kw_loc: "as", ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("char"), hint: None }] }, args: [] }) } }, MatchArm { pats: [Hole], cond: None, expr: Return { kw_loc: "return", expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) } }] }) }, else_expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_escape_ascii" })] }, then_expr: Block { attrs: [], stmts: [], ret: Some(As { expr: MemberCall { obj: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("u8"), hint: None }, Name { name: Ok("from_str_radix"), hint: None }] }), par_loc: "(", args: [MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, Literal(IntLike { ty: None, val: 16 })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, kw_loc: "as", ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("char"), hint: None }] }, args: [] }) }) }, else_expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_escape_unicode" })] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("from_u32"), hint: None }] }), par_loc: "(", args: [MemberCall { obj: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("u32"), hint: None }, Name { name: Ok("from_str_radix"), hint: None }] }), par_loc: "(", args: [MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, Literal(IntLike { ty: None, val: 16 })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }] }, arms: [MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("c"), is_ref: false, is_mut: false, pat: None }] }], cond: None, expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("c"), hint: None }] }) }, MatchArm { pats: [BindLike { name: Ok("None"), is_ref: false, is_mut: false, pat: None }], cond: None, expr: Return { kw_loc: "return", expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) } }] }) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(Return { kw_loc: "return", expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) }) }) }) }) }) }] }] }) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) }) }) }) }) } }) } } }] } }, ItemWrap { attrs: [], is_pub: false, detail: ImplType { templ: [Lifetime { name: "input", bound: None }], ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Tokenizer"), hint: None }] }, args: [Lifetime("input")] }), whs: None, items: [ItemWrap { attrs: [], is_pub: true, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("new"), templ: [], args: [Bind { pat: BindLike { name: Ok("input"), is_ref: false, is_mut: false, pat: None }, ty: Ref { lt: Some("input"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) } }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [SelfTy_("Self")] }, args: [] })), whs: None }, body: Block { attrs: [], stmts: [], ret: Some(Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Tokenizer"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("rest"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("input"), hint: None }] })) }], base: None }) } } }, ItemWrap { attrs: [], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("advance"), templ: [], args: [SelfRef { is_mut: true }, Bind { pat: BindLike { name: Ok("len"), is_ref: false, is_mut: false, pat: None }, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("usize"), hint: None }] }, args: [] }) }], is_va: false, ret_ty: None, whs: None }, body: Block { attrs: [], stmts: [PluginInvoke(PluginInvoke { name: Ok("assert"), ident: None, tt: (Tree { delim: Paren, tts: [(Token(Ident("len")), "len"), (Token(Symbol(Le)), "<="), (Token(Keyword(SelfVar)), "self"), (Token(Symbol(Dot)), "."), (Token(Ident("rest")), "rest"), (Token(Symbol(Dot)), "."), (Token(Ident("len")), "len"), (Tree { delim: Paren, tts: [] }, "()")] }, "(len <= self.rest.len())") }), Expr(BinaryOp { op: Assign, op_loc: "=", l: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, r: UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("len"), hint: None }] }), r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) } } } })], ret: None } } }, ItemWrap { attrs: [Doc { loc: "/// Consume block comment inner(without the starting tag) till the ending tag.\n", doc: " Consume block comment inner(without the starting tag) till the ending tag.\n" }, Doc { loc: "/// Return the comment content.\n", doc: " Return the comment content.\n" }], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("eat_block_comment"), templ: [], args: [SelfRef { is_mut: true }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Ref { lt: Some("input"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) }), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: [] }))] })), whs: None }, body: Block { attrs: [], stmts: [Let { pat: BindLike { name: Ok("sbegin"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } } }, Let { pat: BindLike { name: Ok("layer"), is_ref: false, is_mut: true, pat: None }, ty: Error, expr: Literal(IntLike { ty: None, val: 1 }) }, Expr(While { label: None, cond: BinaryOp { op: Gt, op_loc: ">", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("layer"), hint: None }] }), r: Literal(IntLike { ty: None, val: 0 }) }, body: Block { attrs: [], stmts: [], ret: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("cap"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("RE_BLOCK_COMMENT_BEGIN_END"), hint: None }] }), func: Name { name: Ok("captures"), hint: None }, par_loc: "(", args: [StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }] }, then_expr: Block { attrs: [], stmts: [Expr(MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("advance"), hint: None }, par_loc: "(", args: [MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }) }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }] })], ret: Some(If { cond: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "begin" })] }, func: Name { name: Ok("is_some"), hint: None }, par_loc: "(", args: [] }, then_expr: Block { attrs: [], stmts: [Expr(BinaryOp { op: AddAssign, op_loc: "+=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("layer"), hint: None }] }), r: Literal(IntLike { ty: None, val: 1 }) })], ret: None }, else_expr: Some(Block { attrs: [], stmts: [Expr(BinaryOp { op: SubAssign, op_loc: "-=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("layer"), hint: None }] }), r: Literal(IntLike { ty: None, val: 1 }) })], ret: None }) }) }, else_expr: Some(Block { attrs: [], stmts: [Expr(Return { kw_loc: "return", expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("UnclosedComment"), hint: None }] })] }) })], ret: None }) }) } })], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("sbegin"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }), r: BinaryOp { op: Sub, op_loc: "-", l: BinaryOp { op: Sub, op_loc: "-", l: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("sbegin"), hint: None }] }), func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }, r: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] } }, r: Literal(IntLike { ty: None, val: 2 }) } } } }] }) } } }, ItemWrap { attrs: [Doc { loc: "/// Consume raw string inner(without the starting tag) till the ending tag.\n", doc: " Consume raw string inner(without the starting tag) till the ending tag.\n" }, Doc { loc: "/// Return the content of the string.\n", doc: " Return the content of the string.\n" }], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("eat_raw_string"), templ: [], args: [SelfRef { is_mut: true }, Bind { pat: BindLike { name: Ok("hashes"), is_ref: false, is_mut: false, pat: None }, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("usize"), hint: None }] }, args: [] }) }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Ref { lt: Some("input"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) }), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: [] }))] })), whs: None }, body: Block { attrs: [], stmts: [Let { pat: BindLike { name: Ok("pat"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: PluginInvoke(PluginInvoke { name: Ok("format"), ident: None, tt: (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "\"{}" })), "\"\\\"{}\""), (Token(Symbol(Comma)), ","), (Token(Literal(StrLike { is_bytestr: false, s: "#" })), "\"#\""), (Token(Symbol(Dot)), "."), (Token(Ident("repeat")), "repeat"), (Tree { delim: Paren, tts: [(Token(Ident("hashes")), "hashes")] }, "(hashes)")] }, "(\"\\\"{}\", \"#\".repeat(hashes))") }) }], ret: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("p"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("find"), hint: None }, par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("pat"), hint: None }] }) }] }, then_expr: Block { attrs: [], stmts: [Let { pat: BindLike { name: Ok("content"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }), r: Path(Path { is_absolute: false, comps: [Name { name: Ok("p"), hint: None }] }) } } } }, Expr(MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("advance"), hint: None }, par_loc: "(", args: [BinaryOp { op: Add, op_loc: "+", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("p"), hint: None }] }), r: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("pat"), hint: None }] }), func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] } }] })], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("content"), hint: None }] })] }) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("UnterminatedString"), hint: None }] })] }) }) }) } } }] } }, ItemWrap { attrs: [Doc { loc: "/// Parse a char-like literal captured.\n", doc: " Parse a char-like literal captured.\n" }], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("parse_cap_char"), templ: [Lifetime { name: "a", bound: None }], args: [Bind { pat: BindLike { name: Ok("cap"), is_ref: false, is_mut: false, pat: None }, ty: Ref { lt: None, is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Captures"), hint: None }] }, args: [Lifetime("a")] }) } }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }] }, args: [Lifetime("a")] })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: [] }))] })), whs: None }, body: Block { attrs: [], stmts: [Let { pat: BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(StrLike { is_bytestr: false, s: "char_content" }) } } }], ret: Some(Match { kw_loc: "match", expr: MemberCall { obj: MemberCall { obj: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })] }, func: Name { name: Ok("next"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, arms: [MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [BindLike { name: Ok("ch"), is_ref: false, is_mut: false, pat: None }] }], cond: Some(BinaryOp { op: Ne, op_loc: "!=", l: Index { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_bytes"), hint: None }, par_loc: "(", args: [] }, brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }) }, r: Literal(CharLike { is_byte: true, ch: '\'' }) }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }, Name { name: Ok("CharLike"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("is_byte"), expr: Some(MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_byte" })] }, func: Name { name: Ok("is_some"), hint: None }, par_loc: "(", args: [] }) }, ExprStructField { name: Ok("ch"), expr: None }], base: None }] } }, MatchArm { pats: [Hole], cond: None, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("InvalidEscape"), hint: None }] })] } }] }) } } }, ItemWrap { attrs: [Doc { loc: "/// Parse a number-like literal captured.\n", doc: " Parse a number-like literal captured.\n" }], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("parse_cap_num"), templ: [Lifetime { name: "a", bound: None }], args: [Bind { pat: BindLike { name: Ok("cap"), is_ref: false, is_mut: false, pat: None }, ty: Ref { lt: None, is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Captures"), hint: None }] }, args: [Lifetime("a")] }) } }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }] }, args: [Lifetime("a")] })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: [] }))] })), whs: None }, body: Block { attrs: [], stmts: [Item(ItemWrap { attrs: [], is_pub: false, detail: UseAll { path: Relative { supers: 0, comps: [Ok("Lit")] } } }), Let { pat: BindLike { name: Ok("err"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("InvalidNumberSuffix"), hint: None }] })] } }, Let { pat: Tuple([BindLike { name: Ok("radix"), is_ref: false, is_mut: false, pat: None }, BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }]), ty: Error, expr: IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_bin" })] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Tuple([Literal(IntLike { ty: None, val: 2 }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])) }, else_expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_oct" })] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Tuple([Literal(IntLike { ty: None, val: 8 }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])) }, else_expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_hex" })] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Tuple([Literal(IntLike { ty: None, val: 16 }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])) }, else_expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_body" })] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Tuple([Literal(IntLike { ty: None, val: 10 }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(PluginInvoke(PluginInvoke { name: Ok("unreachable"), ident: None, tt: (Tree { delim: Paren, tts: [] }, "()") })) }) }) }) }) } }, Let { pat: BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("replace"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "_" }), Literal(StrLike { is_bytestr: false, s: "" })] } }, Let { pat: BindLike { name: Ok("lit"), is_ref: false, is_mut: true, pat: None }, ty: Error, expr: If { cond: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_float_like" })] }, func: Name { name: Ok("map_or"), hint: None }, par_loc: "(", args: [Literal(Bool(false)), Lambda { sig: LambdaSig { is_move: false, loc: "|", args: [Bind { pat: BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }, ty: Error }], ret_ty: None }, body: UnaryOp { op: Not, op_loc: "!", expr: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("is_empty"), hint: None }, par_loc: "(", args: [] } } }] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("FloatLike"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("ty"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }, ExprStructField { name: Ok("val"), expr: Some(MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("parse"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }) }], base: None }) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("IntLike"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("ty"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }, ExprStructField { name: Ok("val"), expr: Some(MemberCall { obj: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("imax"), hint: None }, Name { name: Ok("from_str_radix"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }) }, Path(Path { is_absolute: false, comps: [Name { name: Ok("radix"), hint: None }] })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }) }], base: None }) }) } }], ret: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("cap_suf"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("RE_NUM_SUFFIX"), hint: None }] }), func: Name { name: Ok("captures"), hint: None }, par_loc: "(", args: [MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_suffix" })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }] }, then_expr: Block { attrs: [], stmts: [Expr(If { cond: UnaryOp { op: Not, op_loc: "!", expr: MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap_suf"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }) }, func: Name { name: Ok("is_empty"), hint: None }, par_loc: "(", args: [] } }, then_expr: Block { attrs: [], stmts: [Let { pat: BindLike { name: Ok("ty_suf"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ty"), hint: None }, Name { name: Ok("from_name"), hint: None }] }), par_loc: "(", args: [MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap_suf"), hint: None }] }), func: Name { name: Ok("get"), hint: None }, par_loc: "(", args: [Literal(IntLike { ty: None, val: 0 })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }] } }], ret: Some(If { cond: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap_suf"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "int_like" })] }, func: Name { name: Ok("is_some"), hint: None }, par_loc: "(", args: [] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("lit"), hint: None }] }), arms: [MatchArm { pats: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("IntLike"), hint: None }] }, fields: [DestructField { is_ref: true, is_mut: true, name: Ok("ty"), pat: None }], ellipsis: true }], cond: None, expr: BinaryOp { op: Assign, op_loc: "=", l: UnaryOp { op: Deref, op_loc: "*", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("ty"), hint: None }] }) }, r: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Box"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("ty_suf"), hint: None }] })] }] } } }, MatchArm { pats: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("FloatLike"), hint: None }] }, fields: [], ellipsis: true }], cond: None, expr: Return { kw_loc: "return", expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) } }, MatchArm { pats: [Hole], cond: None, expr: PluginInvoke(PluginInvoke { name: Ok("unreachable"), ident: None, tt: (Tree { delim: Paren, tts: [] }, "()") }) }] }) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("lit"), hint: None }] }), arms: [MatchArm { pats: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("IntLike"), hint: None }] }, fields: [DestructField { is_ref: false, is_mut: false, name: Ok("val"), pat: None }], ellipsis: true }], cond: None, expr: BinaryOp { op: Assign, op_loc: "=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("lit"), hint: None }] }), r: Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("FloatLike"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("ty"), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Box"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("ty_suf"), hint: None }] })] }] }) }, ExprStructField { name: Ok("val"), expr: Some(As { expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("val"), hint: None }] }), kw_loc: "as", ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("fmax"), hint: None }] }, args: [] }) }) }], base: None } } }, MatchArm { pats: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("FloatLike"), hint: None }] }, fields: [DestructField { is_ref: true, is_mut: true, name: Ok("ty"), pat: None }], ellipsis: true }], cond: None, expr: BinaryOp { op: Assign, op_loc: "=", l: UnaryOp { op: Deref, op_loc: "*", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("ty"), hint: None }] }) }, r: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Box"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("ty_suf"), hint: None }] })] }] } } }, MatchArm { pats: [Hole], cond: None, expr: PluginInvoke(PluginInvoke { name: Ok("unreachable"), ident: None, tt: (Tree { delim: Paren, tts: [] }, "()") }) }] }) }) }) }, else_expr: None })], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("lit"), hint: None }] })] }) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) }) }) } } }, ItemWrap { attrs: [Doc { loc: "/// Parse a string-like literal.\n", doc: " Parse a string-like literal.\n" }], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("parse_str_string"), templ: [], args: [Bind { pat: BindLike { name: Ok("source"), is_ref: false, is_mut: false, pat: None }, ty: Ref { lt: None, is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) } }, Bind { pat: BindLike { name: Ok("is_bytestr"), is_ref: false, is_mut: false, pat: None }, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("bool"), hint: None }] }, args: [] }) }, Bind { pat: BindLike { name: Ok("is_raw"), is_ref: false, is_mut: false, pat: None }, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("bool"), hint: None }] }, args: [] }) }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }] }, args: [] })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: [] }))] })), whs: None }, body: Block { attrs: [], stmts: [Let { pat: BindLike { name: Ok("s"), is_ref: false, is_mut: true, pat: None }, ty: Error, expr: Error }, Expr(If { cond: Path(Path { is_absolute: false, comps: [Name { name: Ok("is_raw"), hint: None }] }), then_expr: Block { attrs: [], stmts: [], ret: Some(BinaryOp { op: Assign, op_loc: "=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), r: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("String"), hint: None }, Name { name: Ok("from"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("source"), hint: None }] })] } }) }, else_expr: Some(Block { attrs: [], stmts: [Expr(BinaryOp { op: Assign, op_loc: "=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), r: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("String"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [] } })], ret: Some(For { label: None, pat: BindLike { name: Ok("ret"), is_ref: false, is_mut: false, pat: None }, iter: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("source"), hint: None }] })] }, body: Block { attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("ret"), hint: None }] }), arms: [MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [BindLike { name: Ok("c"), is_ref: false, is_mut: false, pat: None }] }], cond: None, expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("push"), hint: None }, par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("c"), hint: None }] })] } }, MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }, elems: [Hole] }], cond: None, expr: UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("InvalidEscape"), hint: None }] })] } } }] }) } }) }) })], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }, Name { name: Ok("StrLike"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("is_bytestr"), expr: None }, ExprStructField { name: Ok("s"), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Rc"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })] }) }], base: None }] }) } } }, ItemWrap { attrs: [], is_pub: false, detail: ImplTrait { templ: [Lifetime { name: "input", bound: None }], tr: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Iterator"), hint: None }] }, args: [] }), ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Tokenizer"), hint: None }] }, args: [Lifetime("input")] }), whs: None, items: [ItemWrap { attrs: [], is_pub: false, detail: AssocTy { name: Ok("Item"), val: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Option"), hint: None }] }, args: [Ty(Tuple([Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("TokenKind"), hint: None }] }, args: [Lifetime("input")] }), Ref { lt: Some("input"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) }]))] })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: [Lifetime("input")] }))] }) } }, ItemWrap { attrs: [], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("next"), templ: [], args: [SelfRef { is_mut: true }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Option"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [SelfTy_("Self"), Name { name: Ok("Item"), hint: None }] }, args: [] }))] })), whs: None }, body: Block { attrs: [], stmts: [Item(ItemWrap { attrs: [], is_pub: false, detail: UseAll { path: Relative { supers: 0, comps: [Ok("TokenKind")] } } }), Item(ItemWrap { attrs: [], is_pub: false, detail: UseAll { path: Relative { supers: 0, comps: [Ok("LexicalErrorKind")] } } }), Let { pat: BindLike { name: Ok("slast"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("trim_left"), hint: None }, par_loc: "(", args: [] } }, Expr(BinaryOp { op: Assign, op_loc: "=", l: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, r: Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] }) })], ret: Some(If { cond: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("is_empty"), hint: None }, par_loc: "(", args: [] }, then_expr: Block { attrs: [], stmts: [], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }, else_expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("cap"), is_ref: false, is_mut: false, pat: None }] }, match_expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("RE_MAIN"), hint: None }] }), func: Name { name: Ok("captures"), hint: None }, par_loc: "(", args: [StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }] }, then_expr: Block { attrs: [], stmts: [Expr(MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("advance"), hint: None }, par_loc: "(", args: [MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }) }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }] }), Let { pat: BindLike { name: Ok("is"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: Lambda { sig: LambdaSig { is_move: false, loc: "|", args: [Bind { pat: BindLike { name: Ok("name"), is_ref: false, is_mut: false, pat: None }, ty: Error }], ret_ty: None }, body: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("name"), hint: None }] })] }, func: Name { name: Ok("is_some"), hint: None }, par_loc: "(", args: [] } } }, Let { pat: BindLike { name: Ok("f"), is_ref: false, is_mut: true, pat: None }, ty: Error, expr: Lambda { sig: LambdaSig { is_move: false, loc: "|", args: [], ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Hole), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: [] }))] })) }, body: Block { attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Match { kw_loc: "match", expr: MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("get"), hint: None }, par_loc: "(", args: [Literal(IntLike { ty: None, val: 0 })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, arms: [MatchArm { pats: [BindLike { name: Ok("m"), is_ref: false, is_mut: false, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "line_innerdoc" })] }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("InnerDoc"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Literal(IntLike { ty: None, val: 3 }), r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) } } }] }] } }, MatchArm { pats: [BindLike { name: Ok("m"), is_ref: false, is_mut: false, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "line_outerdoc" })] }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("OuterDoc"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Literal(IntLike { ty: None, val: 3 }), r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) } } }] }] } }, MatchArm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "line_comment" })] }), expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] }) }, MatchArm { pats: [BindLike { name: Ok("m"), is_ref: false, is_mut: false, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "lifetime" })] }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Lifetime"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Literal(IntLike { ty: None, val: 1 }), r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) } } }] }] } }, MatchArm { pats: [BindLike { name: Ok("m"), is_ref: false, is_mut: false, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "keyword" })] }), expr: If { cond: BinaryOp { op: Equ, op_loc: "==", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), r: Literal(StrLike { is_bytestr: false, s: "true" }) }, then_expr: Block { attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }, Name { name: Ok("Bool"), hint: None }] }), par_loc: "(", args: [Literal(Bool(true))] }] }] }) }, else_expr: Some(If { cond: BinaryOp { op: Equ, op_loc: "==", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), r: Literal(StrLike { is_bytestr: false, s: "false" }) }, then_expr: Block { attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }, Name { name: Ok("Bool"), hint: None }] }), par_loc: "(", args: [Literal(Bool(false))] }] }] }) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Keyword"), hint: None }] }), par_loc: "(", args: [Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("KEYWORDS"), hint: None }] }), brk_loc: "[", index: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }) }] }] }) }) }) } }, MatchArm { pats: [BindLike { name: Ok("m"), is_ref: false, is_mut: false, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "ident" })] }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ident"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] })] }] } }, MatchArm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "block_innerdoc_beg" })] }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("InnerDoc"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("eat_block_comment"), hint: None }, par_loc: "(", args: [] } }] }] } }, MatchArm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char" })] }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("parse_cap_char"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }) }] } }] }] } }, MatchArm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num" })] }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("parse_cap_num"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }) }] } }] }] } }, MatchArm { pats: [BindLike { name: Ok("m"), is_ref: false, is_mut: false, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "symbol" })] }), expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Symbol"), hint: None }] }), par_loc: "(", args: [Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("SYMBOLS"), hint: None }] }), brk_loc: "[", index: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }) }] }] } }, MatchArm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "string" })] }), expr: Block { attrs: [], stmts: [], ret: Some(If { cond: UnaryOp { op: Not, op_loc: "!", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "string_closed" })] } }, then_expr: Block { attrs: [], stmts: [], ret: Some(UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("UnterminatedString"), hint: None }] })] } }) }, else_expr: Some(Block { attrs: [], stmts: [Let { pat: BindLike { name: Ok("content"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "string_content" })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] } }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("parse_str_string"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("content"), hint: None }] }), Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "string_byte" })] }, Literal(Bool(false))] } }] }] }) }) }) } }, MatchArm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "raw_string_beg" })] }), expr: Block { attrs: [], stmts: [Let { pat: BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: UnaryOp { op: Try, op_loc: "?", expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("eat_raw_string"), hint: None }, par_loc: "(", args: [MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(StrLike { is_bytestr: false, s: "raw_string_hashes" }) }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }] } } }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("parse_str_string"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "raw_string_byte" })] }, Literal(Bool(true))] } }] }] }) } }, MatchArm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "block_outerdoc_beg_eat1" })] }), expr: Block { attrs: [], stmts: [Expr(BinaryOp { op: Assign, op_loc: "=", l: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, r: UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: BinaryOp { op: Sub, op_loc: "-", l: MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }) }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }, r: Literal(IntLike { ty: None, val: 1 }) }, r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) } } } })], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("OuterDoc"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("eat_block_comment"), hint: None }, par_loc: "(", args: [] } }] }] }) } }, MatchArm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "block_comment_beg" })] }), expr: Block { attrs: [], stmts: [Expr(UnaryOp { op: Try, op_loc: "?", expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("eat_block_comment"), hint: None }, par_loc: "(", args: [] } })], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) } }, MatchArm { pats: [BindLike { name: Ok("m"), is_ref: false, is_mut: false, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "delimiter" })] }), expr: Block { attrs: [], stmts: [Item(ItemWrap { attrs: [], is_pub: false, detail: UseAll { path: Relative { supers: 0, comps: [Ok("Delimiter")] } } }), Let { pat: BindLike { name: Ok("is_open"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), arms: [MatchArm { pats: [Literal(StrLike { is_bytestr: false, s: "(" }), Literal(StrLike { is_bytestr: false, s: "[" }), Literal(StrLike { is_bytestr: false, s: "{" })], cond: None, expr: Literal(Bool(true)) }, MatchArm { pats: [Hole], cond: None, expr: Literal(Bool(false)) }] } }, Let { pat: BindLike { name: Ok("delim"), is_ref: false, is_mut: false, pat: None }, ty: Error, expr: Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), arms: [MatchArm { pats: [Literal(StrLike { is_bytestr: false, s: "(" }), Literal(StrLike { is_bytestr: false, s: ")" })], cond: None, expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("Paren"), hint: None }] }) }, MatchArm { pats: [Literal(StrLike { is_bytestr: false, s: "[" }), Literal(StrLike { is_bytestr: false, s: "]" })], cond: None, expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("Bracket"), hint: None }] }) }, MatchArm { pats: [Hole], cond: None, expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("Brace"), hint: None }] }) }] } }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Delimiter"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("is_open"), expr: None }, ExprStructField { name: Ok("delim"), expr: None }], base: None }] }) } }, MatchArm { pats: [Hole], cond: None, expr: PluginInvoke(PluginInvoke { name: Ok("unreachable"), ident: None, tt: (Tree { delim: Paren, tts: [] }, "()") }) }] }] }) } } }], ret: Some(Match { kw_loc: "match", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("f"), hint: None }] }), par_loc: "(", args: [] }, arms: [MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [BindLike { name: Ok("None"), is_ref: false, is_mut: false, pat: None }] }], cond: None, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })] }] } }, MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("tokty"), is_ref: false, is_mut: false, pat: None }] }] }], cond: None, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Tuple([Path(Path { is_absolute: false, comps: [Name { name: Ok("tokty"), hint: None }] }), UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }), r: BinaryOp { op: Sub, op_loc: "-", l: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] }), func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }, r: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] } } } } }])] }] }] } }, MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }, elems: [BindLike { name: Ok("e"), is_ref: false, is_mut: false, pat: None }] }], cond: None, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("loc"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] })) }, ExprStructField { name: Ok("kind"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("e"), hint: None }] })) }], base: None }] }] } }] }) }, else_expr: Some(Block { attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("loc"), expr: Some(StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }) }, ExprStructField { name: Ok("kind"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("UnknowToken"), hint: None }] })) }], base: None }] }] }) }) }) }) } } }] } }, ItemWrap { attrs: [], is_pub: false, detail: ImplType { templ: [Lifetime { name: "input", bound: None }], ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lexer"), hint: None }] }, args: [Lifetime("input")] }), whs: None, items: [ItemWrap { attrs: [], is_pub: true, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("new"), templ: [], args: [Bind { pat: BindLike { name: Ok("input"), is_ref: false, is_mut: false, pat: None }, ty: Ref { lt: Some("input"), is_mut: false, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: [] }) } }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [SelfTy_("Self")] }, args: [] })), whs: None }, body: Block { attrs: [], stmts: [], ret: Some(Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lexer"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("tokenizer"), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Tokenizer"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("input"), hint: None }] })] }) }], base: None }) } } }] } }, ItemWrap { attrs: [], is_pub: false, detail: ImplTrait { templ: [Lifetime { name: "input", bound: None }], tr: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Iterator"), hint: None }] }, args: [] }), ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lexer"), hint: None }] }, args: [Lifetime("input")] }), whs: None, items: [ItemWrap { attrs: [], is_pub: false, detail: AssocTy { name: Ok("Item"), val: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Token"), hint: None }] }, args: [Lifetime("input")] })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: [Lifetime("input")] }))] }) } }, ItemWrap { attrs: [], is_pub: false, detail: Func { sig: FuncSig { is_unsafe: false, abi: Normal, name: Ok("next"), templ: [], args: [SelfRef { is_mut: true }], is_va: false, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Option"), hint: None }] }, args: [Ty(Apply(Angle { name: Path { is_absolute: false, comps: [SelfTy_("Self"), Name { name: Ok("Item"), hint: None }] }, args: [] }))] })), whs: None }, body: Block { attrs: [], stmts: [], ret: Some(Loop { label: None, body: Block { attrs: [], stmts: [], ret: Some(Return { kw_loc: "return", expr: Some(Match { kw_loc: "match", expr: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("tokenizer"), hint: None } }, func: Name { name: Ok("next"), hint: None }, par_loc: "(", args: [] }, arms: [MatchArm { pats: [BindLike { name: Ok("None"), is_ref: false, is_mut: false, pat: None }], cond: None, expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] }) }, MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [BindLike { name: Ok("None"), is_ref: false, is_mut: false, pat: None }] }] }], cond: None, expr: Continue { label: None, kw_loc: "continue" } }, MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [Tuple([BindLike { name: Ok("tokty"), is_ref: false, is_mut: false, pat: None }, BindLike { name: Ok("s"), is_ref: false, is_mut: false, pat: None }])] }] }] }], cond: None, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Tuple([Path(Path { is_absolute: false, comps: [Name { name: Ok("tokty"), hint: None }] }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])] }] } }, MatchArm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }, elems: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, fields: [DestructField { is_ref: false, is_mut: false, name: Ok("loc"), pat: None }, DestructField { is_ref: false, is_mut: false, name: Ok("kind"), pat: None }], ellipsis: false }] }] }], cond: None, expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: [] }), fields: [ExprStructField { name: Ok("loc"), expr: None }, ExprStructField { name: Ok("kind"), expr: None }], base: None }] }] } }] }) }) } }) } } }] } }] }
