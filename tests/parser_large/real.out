Mod { inner_attrs: [Doc { loc: "//! This test example is partial copied from `src/mair/parse/lexer.rs`\n", doc: " This test example is partial copied from `src/mair/parse/lexer.rs`\n" }], items: [Item { outer_attrs: [Doc { loc: "/// The regex match a char(maybe escaped).\n", doc: " The regex match a char(maybe escaped).\n" }], pub_: None, detail: Const { name: Ok("RESTR_CHAR"), ty: Some(Ref { lt: Some("static"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }), val: Some(Literal(StrLike { is_bytestr: false, s: "(?x:\n    (?P<char_normal>[[:^cntrl:]&&[^\\\\]])|\n    \\\\(?:\n        (?P<char_escape_simple>[\\\\\'\"nrt0\\n])|\n        x(?P<char_escape_ascii>[[:xdigit:]]{2})|\n        u\\{(?P<char_escape_unicode>[[:xdigit:]]{1,6})\\}\n    )\n)" })), semi: Ok(()) } }, Item { outer_attrs: [], pub_: None, detail: Const { name: Ok("RESTR_NUM"), ty: Some(Ref { lt: Some("static"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }), val: Some(Literal(StrLike { is_bytestr: false, s: "(?x:\n    (?:\n        0b(?P<num_bin>[01_]+)|\n        0o(?P<num_oct>[0-7_]+)|\n        0x(?P<num_hex>[[:xdigit:]]+)|\n        (?P<num_body>\n            \\d[\\d_]*\n            (?P<num_float_like>\n                (?:\\.\\d[\\d_]*)?\n                (?:[Ee][+-]?_*\\d[_\\d]*)?\n            )\n        )\n    )\n    (?P<num_suffix>\\w*)\n)" })), semi: Ok(()) } }, Item { outer_attrs: [], pub_: None, detail: PluginInvoke(PluginInvoke { name: Ok("lazy_static"), ident: None, tt: Some((Tree { delim: Brace, tts: [(Token(Keyword(Static)), "static"), (Token(Keyword(Ref)), "ref"), (Token(Ident("RE_MAIN")), "RE_MAIN"), (Token(Symbol(Colon)), ":"), (Token(Ident("Regex")), "Regex"), (Token(Symbol(Eq)), "="), (Token(Ident("Regex")), "Regex"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("format")), "format"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )" })), "r#\"(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )\"#"), (Token(Symbol(Comma)), ","), (Token(Ident("num")), "num"), (Token(Symbol(Eq)), "="), (Token(Ident("RESTR_NUM")), "RESTR_NUM"), (Token(Symbol(Comma)), ","), (Token(Ident("chr")), "chr"), (Token(Symbol(Eq)), "="), (Token(Ident("RESTR_CHAR")), "RESTR_CHAR"), (Token(Symbol(Comma)), ","), (Token(Ident("symbols")), "symbols"), (Token(Symbol(Eq)), "="), (Token(Symbol(Mul)), "*"), (Token(Ident("RESTR_SYMBOLS")), "RESTR_SYMBOLS"), (Token(Symbol(Comma)), ","), (Token(Ident("keywords")), "keywords"), (Token(Symbol(Eq)), "="), (Token(Symbol(Mul)), "*"), (Token(Ident("RESTR_KEYWORDS")), "RESTR_KEYWORDS")] }, "(r#\"(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )\"#, num=RESTR_NUM, chr=RESTR_CHAR, symbols=*RESTR_SYMBOLS, keywords=*RESTR_KEYWORDS\n    )")] }, "(&format!(r#\"(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )\"#, num=RESTR_NUM, chr=RESTR_CHAR, symbols=*RESTR_SYMBOLS, keywords=*RESTR_KEYWORDS\n    ))"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Static)), "static"), (Token(Keyword(Ref)), "ref"), (Token(Ident("RE_BLOCK_COMMENT_BEGIN_END")), "RE_BLOCK_COMMENT_BEGIN_END"), (Token(Symbol(Colon)), ":"), (Token(Ident("Regex")), "Regex"), (Token(Symbol(Eq)), "="), (Token(Ident("Regex")), "Regex"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "(?s).*?(?:(?P<begin>/\\*)|\\*/)" })), "r\"(?s).*?(?:(?P<begin>/\\*)|\\*/)\""), (Token(Symbol(Comma)), ",")] }, "(\n        r\"(?s).*?(?:(?P<begin>/\\*)|\\*/)\",\n    )"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";"), (Token(Keyword(Static)), "static"), (Token(Keyword(Ref)), "ref"), (Token(Ident("RE_NUM_SUFFIX")), "RE_NUM_SUFFIX"), (Token(Symbol(Colon)), ":"), (Token(Ident("Regex")), "Regex"), (Token(Symbol(Eq)), "="), (Token(Ident("Regex")), "Regex"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "(?x)\\A(?:\n            (?P<int_like>[iu](?:8|16|32|64|size))|\n            f(?:32|64)\n        )?\\z" })), "r\"(?x)\\A(?:\n            (?P<int_like>[iu](?:8|16|32|64|size))|\n            f(?:32|64)\n        )?\\z\"")] }, "(\n        r\"(?x)\\A(?:\n            (?P<int_like>[iu](?:8|16|32|64|size))|\n            f(?:32|64)\n        )?\\z\"\n    )"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";")] }, "{\n    static ref RE_MAIN: Regex = Regex::new(&format!(r#\"(?xsm)\\A(?:\n        (?P<line_innerdoc>//!.*?(?:\\z|\\n))|\n        (?P<line_outerdoc>///(?:[^/].*?)??(?:\\z|\\n))|\n        (?P<line_comment>//.*?$)|\n        (?P<block_innerdoc_beg>/\\*!)|\n        (?P<block_outerdoc_beg_eat1>/\\*\\*[^*/])|\n        (?P<block_comment_beg>/\\*)|\n        (?P<num>{num})|\n        (?P<raw_string_beg>(?P<raw_string_byte>b)?r(?P<raw_string_hashes>\\#*)\")|\n        (?P<string>\n            (?P<string_byte>b)?\"\n            (?P<string_content>[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\n            (?P<string_closed>\")?\n        )|\n        (?P<char>(?P<char_byte>b)?\'(?P<char_content>{chr})\')|\n        (?P<lifetime>\'[A-Za-z_]\\w*)|\n        (?P<delimiter>\\(|\\[|\\{{|\\}}|\\]|\\))|\n        (?P<symbol>{symbols})|\n        (?P<keyword>(?:{keywords})\\b)|\n        (?P<ident>[A-Za-z_]\\w*)\n    )\"#, num=RESTR_NUM, chr=RESTR_CHAR, symbols=*RESTR_SYMBOLS, keywords=*RESTR_KEYWORDS\n    )).unwrap();\n\n    static ref RE_BLOCK_COMMENT_BEGIN_END: Regex = Regex::new(\n        r\"(?s).*?(?:(?P<begin>/\\*)|\\*/)\",\n    ).unwrap();\n\n    static ref RE_NUM_SUFFIX: Regex = Regex::new(\n        r\"(?x)\\A(?:\n            (?P<int_like>[iu](?:8|16|32|64|size))|\n            f(?:32|64)\n        )?\\z\"\n    ).unwrap();\n}")) }) }, Item { outer_attrs: [], pub_: None, detail: ImplType { templ: [Lifetime { name: "a", bound: None }], ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }] }, args: Some([Lifetime("a")]) }), whs: None, inner: Some(Mod { inner_attrs: [], items: [Item { outer_attrs: [], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("new"), templ: [], args: Some([Bind { pat: BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }, ty: Some(Ref { lt: Some("a"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }) }]), va: None, ret_ty: Some(Self_), whs: None }, body: Block { inner_attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })] }) } } }] }) } }, Item { outer_attrs: [], pub_: None, detail: ImplTrait { templ: [Lifetime { name: "a", bound: None }], tr: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Iterator"), hint: None }] }, args: None }), ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }] }, args: Some([Lifetime("a")]) }), whs: None, inner: Some(Mod { inner_attrs: [], items: [Item { outer_attrs: [], pub_: None, detail: Type { alias: Ok("Item"), templ: [], whs: None, origin: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("char"), hint: None }] }, args: None })), Ty(Ref { lt: Some("a"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) })]) })), semi: Ok(()) } }, Item { outer_attrs: [], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("next"), templ: [], args: Some([SelfRef { mut_: Some("mut") }]), va: None, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Option"), hint: None }] }, args: Some([Ty(Self_), Unknow((Token(Symbol(ColonColon)), "::")), Unknow((Token(Ident("Item")), "Item"))]) })), whs: None }, body: Block { inner_attrs: [], stmts: [PluginInvoke { p: PluginInvoke { name: Ok("lazy_static"), ident: None, tt: Some((Tree { delim: Brace, tts: [(Token(Keyword(Static)), "static"), (Token(Keyword(Ref)), "ref"), (Token(Ident("RE_ESCAPED")), "RE_ESCAPED"), (Token(Symbol(Colon)), ":"), (Token(Ident("Regex")), "Regex"), (Token(Symbol(Eq)), "="), (Token(Ident("Regex")), "Regex"), (Token(Symbol(ColonColon)), "::"), (Token(Ident("new")), "new"), (Tree { delim: Paren, tts: [(Token(Symbol(And)), "&"), (Token(Ident("format")), "format"), (Token(Symbol(Bang)), "!"), (Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "\\A{}" })), "r\"\\A{}\""), (Token(Symbol(Comma)), ","), (Token(Ident("RESTR_CHAR")), "RESTR_CHAR")] }, "(r\"\\A{}\", RESTR_CHAR)")] }, "(\n                &format!(r\"\\A{}\", RESTR_CHAR)\n            )"), (Token(Symbol(Dot)), "."), (Token(Ident("unwrap")), "unwrap"), (Tree { delim: Paren, tts: [] }, "()"), (Token(Symbol(Semi)), ";")] }, "{\n            static ref RE_ESCAPED: Regex = Regex::new(\n                &format!(r\"\\A{}\", RESTR_CHAR)\n            ).unwrap();\n        }")) }, semi: Ok(()) }, Let { pat: BindLike { name: Ok("err"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }] }] }), semi: Ok(()) }], ret: Some(Loop { label: None, body: Some(Block { inner_attrs: [], stmts: [], ret: Some(Return { kw_loc: "return", expr: Some(If { cond: MemberCall { obj: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, func: Name { name: Ok("is_empty"), hint: None }, par_loc: "(", args: [] }, then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }), else_expr: Some(Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("cap"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("RE_ESCAPED"), hint: None }] }), func: Name { name: Ok("captures"), hint: None }, par_loc: "(", args: [TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }] }), then_expr: Some(Block { inner_attrs: [], stmts: [Expr { expr: BinaryOp { op: Assign, op_loc: "=", l: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, r: UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }), unknow: [] }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }, r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) }, unknow: [] } } }, semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_normal" })] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(MemberCall { obj: MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("chars"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("next"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }) }), else_expr: Some(Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_escape_simple" })] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Index { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_bytes"), hint: None }, par_loc: "(", args: [] }, brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }), unknow: [] }, arms: Some([Arm { pats: [Literal(CharLike { is_byte: true, ch: 'n' })], cond: None, expr: Some(Literal(CharLike { is_byte: false, ch: '\n' })) }, Arm { pats: [Literal(CharLike { is_byte: true, ch: 'r' })], cond: None, expr: Some(Literal(CharLike { is_byte: false, ch: '\r' })) }, Arm { pats: [Literal(CharLike { is_byte: true, ch: 't' })], cond: None, expr: Some(Literal(CharLike { is_byte: false, ch: '\t' })) }, Arm { pats: [Literal(CharLike { is_byte: true, ch: '0' })], cond: None, expr: Some(Literal(CharLike { is_byte: false, ch: '\u{0}' })) }, Arm { pats: [Literal(CharLike { is_byte: true, ch: '\n' })], cond: None, expr: Some(Block { inner_attrs: [], stmts: [Expr { expr: BinaryOp { op: Assign, op_loc: "=", l: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, r: MemberCall { obj: TupleField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), ind_loc: "0", index: 0 }, func: Name { name: Ok("trim_left"), hint: None }, par_loc: "(", args: [] } }, semi: Ok(()) }], ret: Some(Continue { label: None, kw_loc: "continue" }) }) }, Arm { pats: [BindLike { name: Ok("c"), ref_: None, mut_: None, pat: None }], cond: Some(MemberCall { obj: Literal(StrLike { is_bytestr: true, s: "\\\\\'\"nrt0" }), func: Name { name: Ok("contains"), hint: None }, par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("c"), hint: None }] }) }] }), expr: Some(As { expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("c"), hint: None }] }), kw_loc: "as", ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("char"), hint: None }] }, args: None }) }) }, Arm { pats: [Hole], cond: None, expr: Some(Return { kw_loc: "return", expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) }) }]) }) }), else_expr: Some(Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_escape_ascii" })] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(As { expr: MemberCall { obj: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("u8"), hint: None }, Name { name: Ok("from_str_radix"), hint: None }] }), par_loc: "(", args: [MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, Literal(IntLike { ty: None, val: 16 })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, kw_loc: "as", ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("char"), hint: None }] }, args: None }) }) }), else_expr: Some(Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_escape_unicode" })] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("from_u32"), hint: None }] }), par_loc: "(", args: [MemberCall { obj: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("u32"), hint: None }, Name { name: Ok("from_str_radix"), hint: None }] }), par_loc: "(", args: [MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, Literal(IntLike { ty: None, val: 16 })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }] }, arms: Some([Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("c"), ref_: None, mut_: None, pat: None }] }], cond: None, expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("c"), hint: None }] })) }, Arm { pats: [BindLike { name: Ok("None"), ref_: None, mut_: None, pat: None }], cond: None, expr: Some(Return { kw_loc: "return", expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) }) }]) }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(Return { kw_loc: "return", expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) }) })) })) })) })) }] }] }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) })) })) }) }) }) }) } } }] }) } }, Item { outer_attrs: [], pub_: None, detail: ImplType { templ: [Lifetime { name: "input", bound: None }], ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Tokenizer"), hint: None }] }, args: Some([Lifetime("input")]) }), whs: None, inner: Some(Mod { inner_attrs: [], items: [Item { outer_attrs: [], pub_: Some("pub"), detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("new"), templ: [], args: Some([Bind { pat: BindLike { name: Ok("input"), ref_: None, mut_: None, pat: None }, ty: Some(Ref { lt: Some("input"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }) }]), va: None, ret_ty: Some(Self_), whs: None }, body: Block { inner_attrs: [], stmts: [], ret: Some(Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Tokenizer"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("rest"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("input"), hint: None }] })) }]), base: None }) } } }, Item { outer_attrs: [], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("advance"), templ: [], args: Some([SelfRef { mut_: Some("mut") }, Bind { pat: BindLike { name: Ok("len"), ref_: None, mut_: None, pat: None }, ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("usize"), hint: None }] }, args: None })) }]), va: None, ret_ty: None, whs: None }, body: Block { inner_attrs: [], stmts: [PluginInvoke { p: PluginInvoke { name: Ok("assert"), ident: None, tt: Some((Tree { delim: Paren, tts: [(Token(Ident("len")), "len"), (Token(Symbol(Le)), "<="), (Token(Keyword(SelfVar)), "self"), (Token(Symbol(Dot)), "."), (Token(Ident("rest")), "rest"), (Token(Symbol(Dot)), "."), (Token(Ident("len")), "len"), (Tree { delim: Paren, tts: [] }, "()")] }, "(len <= self.rest.len())")) }, semi: Ok(()) }, Expr { expr: BinaryOp { op: Assign, op_loc: "=", l: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, r: UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("len"), hint: None }] }), r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) }, unknow: [] } } }, semi: Ok(()) }], ret: None } } }, Item { outer_attrs: [Doc { loc: "/// Consume block comment inner(without the starting tag) till the ending tag.\n", doc: " Consume block comment inner(without the starting tag) till the ending tag.\n" }, Doc { loc: "/// Return the comment content.\n", doc: " Return the comment content.\n" }], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("eat_block_comment"), templ: [], args: Some([SelfRef { mut_: Some("mut") }]), va: None, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Ref { lt: Some("input"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: None }))]) })), whs: None }, body: Block { inner_attrs: [], stmts: [Let { pat: BindLike { name: Ok("sbegin"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }), semi: Ok(()) }, Let { pat: BindLike { name: Ok("layer"), ref_: None, mut_: Some("mut"), pat: None }, ty: None, expr: Some(Literal(IntLike { ty: None, val: 1 })), semi: Ok(()) }, Expr { expr: While { label: None, cond: BinaryOp { op: Gt, op_loc: ">", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("layer"), hint: None }] }), r: Literal(IntLike { ty: None, val: 0 }) }, body: Some(Block { inner_attrs: [], stmts: [], ret: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("cap"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("RE_BLOCK_COMMENT_BEGIN_END"), hint: None }] }), func: Name { name: Ok("captures"), hint: None }, par_loc: "(", args: [StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }] }), then_expr: Some(Block { inner_attrs: [], stmts: [Expr { expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("advance"), hint: None }, par_loc: "(", args: [MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }), unknow: [] }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }] }, semi: Ok(()) }], ret: Some(If { cond: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "begin" })] }, func: Name { name: Ok("is_some"), hint: None }, par_loc: "(", args: [] }, then_expr: Some(Block { inner_attrs: [], stmts: [Expr { expr: BinaryOp { op: AddAssign, op_loc: "+=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("layer"), hint: None }] }), r: Literal(IntLike { ty: None, val: 1 }) }, semi: Ok(()) }], ret: None }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [Expr { expr: BinaryOp { op: SubAssign, op_loc: "-=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("layer"), hint: None }] }), r: Literal(IntLike { ty: None, val: 1 }) }, semi: Ok(()) }], ret: None })) }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [Expr { expr: Return { kw_loc: "return", expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("UnclosedComment"), hint: None }] })] }) }, semi: Ok(()) }], ret: None })) }) }) }, semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("sbegin"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }), r: BinaryOp { op: Sub, op_loc: "-", l: BinaryOp { op: Sub, op_loc: "-", l: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("sbegin"), hint: None }] }), func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }, r: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] } }, r: Literal(IntLike { ty: None, val: 2 }) } }, unknow: [] } }] }) } } }, Item { outer_attrs: [Doc { loc: "/// Consume raw string inner(without the starting tag) till the ending tag.\n", doc: " Consume raw string inner(without the starting tag) till the ending tag.\n" }, Doc { loc: "/// Return the content of the string.\n", doc: " Return the content of the string.\n" }], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("eat_raw_string"), templ: [], args: Some([SelfRef { mut_: Some("mut") }, Bind { pat: BindLike { name: Ok("hashes"), ref_: None, mut_: None, pat: None }, ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("usize"), hint: None }] }, args: None })) }]), va: None, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Ref { lt: Some("input"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: None }))]) })), whs: None }, body: Block { inner_attrs: [], stmts: [Let { pat: BindLike { name: Ok("pat"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(PluginInvoke(PluginInvoke { name: Ok("format"), ident: None, tt: Some((Tree { delim: Paren, tts: [(Token(Literal(StrLike { is_bytestr: false, s: "\"{}" })), "\"\\\"{}\""), (Token(Symbol(Comma)), ","), (Token(Literal(StrLike { is_bytestr: false, s: "#" })), "\"#\""), (Token(Symbol(Dot)), "."), (Token(Ident("repeat")), "repeat"), (Tree { delim: Paren, tts: [(Token(Ident("hashes")), "hashes")] }, "(hashes)")] }, "(\"\\\"{}\", \"#\".repeat(hashes))")) })), semi: Ok(()) }], ret: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("p"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("find"), hint: None }, par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("pat"), hint: None }] }) }] }), then_expr: Some(Block { inner_attrs: [], stmts: [Let { pat: BindLike { name: Ok("content"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }), r: Path(Path { is_absolute: false, comps: [Name { name: Ok("p"), hint: None }] }) }, unknow: [] } }), semi: Ok(()) }, Expr { expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("advance"), hint: None }, par_loc: "(", args: [BinaryOp { op: Add, op_loc: "+", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("p"), hint: None }] }), r: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("pat"), hint: None }] }), func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] } }] }, semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("content"), hint: None }] })] }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("UnterminatedString"), hint: None }] })] }) })) }) } } }] }) } }, Item { outer_attrs: [Doc { loc: "/// Parse a char-like literal captured.\n", doc: " Parse a char-like literal captured.\n" }], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("parse_cap_char"), templ: [Lifetime { name: "a", bound: None }], args: Some([Bind { pat: BindLike { name: Ok("cap"), ref_: None, mut_: None, pat: None }, ty: Some(Ref { lt: None, mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Captures"), hint: None }] }, args: Some([Lifetime("a")]) }) }) }]), va: None, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }] }, args: Some([Lifetime("a")]) })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: None }))]) })), whs: None }, body: Block { inner_attrs: [], stmts: [Let { pat: BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(StrLike { is_bytestr: false, s: "char_content" }), unknow: [] } }), semi: Ok(()) }], ret: Some(Match { kw_loc: "match", expr: MemberCall { obj: MemberCall { obj: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })] }, func: Name { name: Ok("next"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, arms: Some([Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [BindLike { name: Ok("ch"), ref_: None, mut_: None, pat: None }] }], cond: Some(BinaryOp { op: Ne, op_loc: "!=", l: Index { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_bytes"), hint: None }, par_loc: "(", args: [] }, brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }), unknow: [] }, r: Literal(CharLike { is_byte: true, ch: '\'' }) }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }, Name { name: Ok("CharLike"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("is_byte"), expr: Some(MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char_byte" })] }, func: Name { name: Ok("is_some"), hint: None }, par_loc: "(", args: [] }) }, Field { name: Ok("ch"), expr: None }]), base: None }] }) }, Arm { pats: [Hole], cond: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("InvalidEscape"), hint: None }] })] }) }]) }) } } }, Item { outer_attrs: [Doc { loc: "/// Parse a number-like literal captured.\n", doc: " Parse a number-like literal captured.\n" }], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("parse_cap_num"), templ: [Lifetime { name: "a", bound: None }], args: Some([Bind { pat: BindLike { name: Ok("cap"), ref_: None, mut_: None, pat: None }, ty: Some(Ref { lt: None, mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Captures"), hint: None }] }, args: Some([Lifetime("a")]) }) }) }]), va: None, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }] }, args: Some([Lifetime("a")]) })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: None }))]) })), whs: None }, body: Block { inner_attrs: [], stmts: [Item(Item { outer_attrs: [], pub_: None, detail: UseAll { path: Path { is_absolute: false, comps: [Self_("self"), Name { name: Ok("Lit"), hint: None }] }, semi: Ok(()) } }), Let { pat: BindLike { name: Ok("err"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("InvalidNumberSuffix"), hint: None }] })] }), semi: Ok(()) }, Let { pat: Tuple([BindLike { name: Ok("radix"), ref_: None, mut_: None, pat: None }, BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }]), ty: None, expr: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_bin" })] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Tuple([Literal(IntLike { ty: None, val: 2 }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])) }), else_expr: Some(Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_oct" })] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Tuple([Literal(IntLike { ty: None, val: 8 }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])) }), else_expr: Some(Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_hex" })] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Tuple([Literal(IntLike { ty: None, val: 16 }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])) }), else_expr: Some(Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_body" })] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Tuple([Literal(IntLike { ty: None, val: 10 }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(PluginInvoke(PluginInvoke { name: Ok("unreachable"), ident: None, tt: Some((Tree { delim: Paren, tts: [] }, "()")) })) })) })) })) })) }), semi: Ok(()) }, Let { pat: BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("replace"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "_" }), Literal(StrLike { is_bytestr: false, s: "" })] }), semi: Ok(()) }, Let { pat: BindLike { name: Ok("lit"), ref_: None, mut_: Some("mut"), pat: None }, ty: None, expr: Some(If { cond: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_float_like" })] }, func: Name { name: Ok("map_or"), hint: None }, par_loc: "(", args: [Literal(Bool(false)), Lambda { sig: LambdaSig { move_: None, loc: "|", args: [Bind { pat: BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }, ty: None }], ret_ty: None }, body: Some(UnaryOp { op: Not, op_loc: "!", expr: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("is_empty"), hint: None }, par_loc: "(", args: [] } }) }] }, then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("FloatLike"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("ty"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }, Field { name: Ok("val"), expr: Some(MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("parse"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }) }]), base: None }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("IntLike"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("ty"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }, Field { name: Ok("val"), expr: Some(MemberCall { obj: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("imax"), hint: None }, Name { name: Ok("from_str_radix"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }) }, Path(Path { is_absolute: false, comps: [Name { name: Ok("radix"), hint: None }] })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }) }]), base: None }) })) }), semi: Ok(()) }], ret: Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("cap_suf"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("RE_NUM_SUFFIX"), hint: None }] }), func: Name { name: Ok("captures"), hint: None }, par_loc: "(", args: [MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num_suffix" })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }] }), then_expr: Some(Block { inner_attrs: [], stmts: [Expr { expr: If { cond: UnaryOp { op: Not, op_loc: "!", expr: MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap_suf"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }), unknow: [] }, func: Name { name: Ok("is_empty"), hint: None }, par_loc: "(", args: [] } }, then_expr: Some(Block { inner_attrs: [], stmts: [Let { pat: BindLike { name: Ok("ty_suf"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ty"), hint: None }, Name { name: Ok("from_name"), hint: None }] }), par_loc: "(", args: [MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap_suf"), hint: None }] }), func: Name { name: Ok("get"), hint: None }, par_loc: "(", args: [Literal(IntLike { ty: None, val: 0 })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }] }), semi: Ok(()) }], ret: Some(If { cond: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap_suf"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "int_like" })] }, func: Name { name: Ok("is_some"), hint: None }, par_loc: "(", args: [] }, then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("lit"), hint: None }] }), arms: Some([Arm { pats: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("IntLike"), hint: None }] }, fields: [Field { name: Err(""), pat: None }, Unknow((Token(Keyword(Ref)), "ref")), Unknow((Token(Keyword(Mut)), "mut")), Unknow((Token(Ident("ty")), "ty"))], ellipsis: true }], cond: None, expr: Some(BinaryOp { op: Assign, op_loc: "=", l: UnaryOp { op: Deref, op_loc: "*", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("ty"), hint: None }] }) }, r: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Box"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("ty_suf"), hint: None }] })] }] } }) }, Arm { pats: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("FloatLike"), hint: None }] }, fields: [], ellipsis: true }], cond: None, expr: Some(Return { kw_loc: "return", expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) }) }, Arm { pats: [Hole], cond: None, expr: Some(PluginInvoke(PluginInvoke { name: Ok("unreachable"), ident: None, tt: Some((Tree { delim: Paren, tts: [] }, "()")) })) }]) }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("lit"), hint: None }] }), arms: Some([Arm { pats: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("IntLike"), hint: None }] }, fields: [Field { name: Ok("val"), pat: None }], ellipsis: true }], cond: None, expr: Some(BinaryOp { op: Assign, op_loc: "=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("lit"), hint: None }] }), r: Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("FloatLike"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("ty"), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Box"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("ty_suf"), hint: None }] })] }] }) }, Field { name: Ok("val"), expr: Some(As { expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("val"), hint: None }] }), kw_loc: "as", ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("fmax"), hint: None }] }, args: None }) }) }]), base: None } }) }, Arm { pats: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("FloatLike"), hint: None }] }, fields: [Field { name: Err(""), pat: None }, Unknow((Token(Keyword(Ref)), "ref")), Unknow((Token(Keyword(Mut)), "mut")), Unknow((Token(Ident("ty")), "ty"))], ellipsis: true }], cond: None, expr: Some(BinaryOp { op: Assign, op_loc: "=", l: UnaryOp { op: Deref, op_loc: "*", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("ty"), hint: None }] }) }, r: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Box"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("ty_suf"), hint: None }] })] }] } }) }, Arm { pats: [Hole], cond: None, expr: Some(PluginInvoke(PluginInvoke { name: Ok("unreachable"), ident: None, tt: Some((Tree { delim: Paren, tts: [] }, "()")) })) }]) }) })) }) }), else_expr: None }, semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("lit"), hint: None }] })] }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("err"), hint: None }] })) })) }) } } }, Item { outer_attrs: [Doc { loc: "/// Parse a string-like literal.\n", doc: " Parse a string-like literal.\n" }], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("parse_str_string"), templ: [], args: Some([Bind { pat: BindLike { name: Ok("source"), ref_: None, mut_: None, pat: None }, ty: Some(Ref { lt: None, mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }) }, Bind { pat: BindLike { name: Ok("is_bytestr"), ref_: None, mut_: None, pat: None }, ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("bool"), hint: None }] }, args: None })) }, Bind { pat: BindLike { name: Ok("is_raw"), ref_: None, mut_: None, pat: None }, ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("bool"), hint: None }] }, args: None })) }]), va: None, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }] }, args: None })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: None }))]) })), whs: None }, body: Block { inner_attrs: [], stmts: [Let { pat: BindLike { name: Ok("s"), ref_: None, mut_: Some("mut"), pat: None }, ty: None, expr: None, semi: Ok(()) }, Expr { expr: If { cond: Path(Path { is_absolute: false, comps: [Name { name: Ok("is_raw"), hint: None }] }), then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(BinaryOp { op: Assign, op_loc: "=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), r: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("String"), hint: None }, Name { name: Ok("from"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("source"), hint: None }] })] } }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [Expr { expr: BinaryOp { op: Assign, op_loc: "=", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), r: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("String"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [] } }, semi: Ok(()) }], ret: Some(For { label: None, pat: BindLike { name: Ok("ret"), ref_: None, mut_: None, pat: None }, iter: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("EscapedChars"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("source"), hint: None }] })] }), body: Some(Block { inner_attrs: [], stmts: [], ret: Some(Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("ret"), hint: None }] }), arms: Some([Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [BindLike { name: Ok("c"), ref_: None, mut_: None, pat: None }] }], cond: None, expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), func: Name { name: Ok("push"), hint: None }, par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("c"), hint: None }] })] }) }, Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }, elems: [Hole] }], cond: None, expr: Some(UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }, Name { name: Ok("InvalidEscape"), hint: None }] })] } }) }]) }) }) }) })) }, semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }, Name { name: Ok("StrLike"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("is_bytestr"), expr: None }, Field { name: Ok("s"), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Rc"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })] }) }]), base: None }] }) } } }, Item { outer_attrs: [], pub_: None, detail: ImplTrait { templ: [Lifetime { name: "input", bound: None }], tr: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Iterator"), hint: None }] }, args: None }), ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Tokenizer"), hint: None }] }, args: Some([Lifetime("input")]) }), whs: None, inner: Some(Mod { inner_attrs: [], items: [Item { outer_attrs: [], pub_: None, detail: Type { alias: Ok("Item"), templ: [], whs: None, origin: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Option"), hint: None }] }, args: Some([Ty(Tuple([Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("TokenKind"), hint: None }] }, args: Some([Lifetime("input")]) }), Ref { lt: Some("input"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }]))]) })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: Some([Lifetime("input")]) }))]) })), semi: Ok(()) } }, Item { outer_attrs: [], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("next"), templ: [], args: Some([SelfRef { mut_: Some("mut") }]), va: None, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Option"), hint: None }] }, args: Some([Ty(Self_), Unknow((Token(Symbol(ColonColon)), "::")), Unknow((Token(Ident("Item")), "Item"))]) })), whs: None }, body: Block { inner_attrs: [], stmts: [Item(Item { outer_attrs: [], pub_: None, detail: UseAll { path: Path { is_absolute: false, comps: [Self_("self"), Name { name: Ok("TokenKind"), hint: None }] }, semi: Ok(()) } }), Item(Item { outer_attrs: [], pub_: None, detail: UseAll { path: Path { is_absolute: false, comps: [Self_("self"), Name { name: Ok("LexicalErrorKind"), hint: None }] }, semi: Ok(()) } }), Let { pat: BindLike { name: Ok("slast"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("trim_left"), hint: None }, par_loc: "(", args: [] }), semi: Ok(()) }, Expr { expr: BinaryOp { op: Assign, op_loc: "=", l: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, r: Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] }) }, semi: Ok(()) }], ret: Some(If { cond: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("is_empty"), hint: None }, par_loc: "(", args: [] }, then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }), else_expr: Some(Some(IfLet { pat: DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("cap"), ref_: None, mut_: None, pat: None }] }, match_expr: Some(MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("RE_MAIN"), hint: None }] }), func: Name { name: Ok("captures"), hint: None }, par_loc: "(", args: [StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }] }), then_expr: Some(Block { inner_attrs: [], stmts: [Expr { expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("advance"), hint: None }, par_loc: "(", args: [MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }), unknow: [] }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }] }, semi: Ok(()) }, Let { pat: BindLike { name: Ok("is"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(Lambda { sig: LambdaSig { move_: None, loc: "|", args: [Bind { pat: BindLike { name: Ok("name"), ref_: None, mut_: None, pat: None }, ty: None }], ret_ty: None }, body: Some(MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("name"), hint: None }] })] }, func: Name { name: Ok("is_some"), hint: None }, par_loc: "(", args: [] }) }), semi: Ok(()) }, Let { pat: BindLike { name: Ok("f"), ref_: None, mut_: Some("mut"), pat: None }, ty: None, expr: Some(Lambda { sig: LambdaSig { move_: None, loc: "|", args: [], ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Hole), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalErrorKind"), hint: None }] }, args: None }))]) })) }, body: Some(Block { inner_attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Match { kw_loc: "match", expr: MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("get"), hint: None }, par_loc: "(", args: [Literal(IntLike { ty: None, val: 0 })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }, arms: Some([Arm { pats: [BindLike { name: Ok("m"), ref_: None, mut_: None, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "line_innerdoc" })] }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("InnerDoc"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Literal(IntLike { ty: None, val: 3 }), r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) }, unknow: [] } }] }] }) }, Arm { pats: [BindLike { name: Ok("m"), ref_: None, mut_: None, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "line_outerdoc" })] }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("OuterDoc"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Literal(IntLike { ty: None, val: 3 }), r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) }, unknow: [] } }] }] }) }, Arm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "line_comment" })] }), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }, Arm { pats: [BindLike { name: Ok("m"), ref_: None, mut_: None, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "lifetime" })] }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Lifetime"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Literal(IntLike { ty: None, val: 1 }), r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) }, unknow: [] } }] }] }) }, Arm { pats: [BindLike { name: Ok("m"), ref_: None, mut_: None, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "keyword" })] }), expr: Some(If { cond: BinaryOp { op: Equ, op_loc: "==", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), r: Literal(StrLike { is_bytestr: false, s: "true" }) }, then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }, Name { name: Ok("Bool"), hint: None }] }), par_loc: "(", args: [Literal(Bool(true))] }] }] }) }), else_expr: Some(Some(If { cond: BinaryOp { op: Equ, op_loc: "==", l: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), r: Literal(StrLike { is_bytestr: false, s: "false" }) }, then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Lit"), hint: None }, Name { name: Ok("Bool"), hint: None }] }), par_loc: "(", args: [Literal(Bool(false))] }] }] }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Keyword"), hint: None }] }), par_loc: "(", args: [Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("KEYWORDS"), hint: None }] }), brk_loc: "[", index: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), unknow: [] }] }] }) })) })) }) }, Arm { pats: [BindLike { name: Ok("m"), ref_: None, mut_: None, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "ident" })] }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ident"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] })] }] }) }, Arm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "block_innerdoc_beg" })] }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("InnerDoc"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("eat_block_comment"), hint: None }, par_loc: "(", args: [] } }] }] }) }, Arm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "char" })] }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("parse_cap_char"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }) }] } }] }] }) }, Arm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "num" })] }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("parse_cap_num"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Borrow, op_loc: "&", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }) }] } }] }] }) }, Arm { pats: [BindLike { name: Ok("m"), ref_: None, mut_: None, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "symbol" })] }), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Symbol"), hint: None }] }), par_loc: "(", args: [Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("SYMBOLS"), hint: None }] }), brk_loc: "[", index: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), unknow: [] }] }] }) }, Arm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "string" })] }), expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(If { cond: UnaryOp { op: Not, op_loc: "!", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "string_closed" })] } }, then_expr: Some(Block { inner_attrs: [], stmts: [], ret: Some(UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("UnterminatedString"), hint: None }] })] } }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [Let { pat: BindLike { name: Ok("content"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(MemberCall { obj: MemberCall { obj: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), func: Name { name: Ok("name"), hint: None }, par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "string_content" })] }, func: Name { name: Ok("unwrap"), hint: None }, par_loc: "(", args: [] }, func: Name { name: Ok("as_str"), hint: None }, par_loc: "(", args: [] }), semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("parse_str_string"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("content"), hint: None }] }), Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "string_byte" })] }, Literal(Bool(false))] } }] }] }) })) }) }) }, Arm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "raw_string_beg" })] }), expr: Some(Block { inner_attrs: [], stmts: [Let { pat: BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(UnaryOp { op: Try, op_loc: "?", expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("eat_raw_string"), hint: None }, par_loc: "(", args: [MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(StrLike { is_bytestr: false, s: "raw_string_hashes" }), unknow: [] }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }] } }), semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Literal"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("parse_str_string"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] }), Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "raw_string_byte" })] }, Literal(Bool(true))] } }] }] }) }) }, Arm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "block_outerdoc_beg_eat1" })] }), expr: Some(Block { inner_attrs: [], stmts: [Expr { expr: BinaryOp { op: Assign, op_loc: "=", l: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, r: UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: BinaryOp { op: Sub, op_loc: "-", l: MemberCall { obj: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("cap"), hint: None }] }), brk_loc: "[", index: Literal(IntLike { ty: None, val: 0 }), unknow: [] }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }, r: Literal(IntLike { ty: None, val: 1 }) }, r: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }) }, unknow: [] } } }, semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("OuterDoc"), hint: None }] }), par_loc: "(", args: [UnaryOp { op: Try, op_loc: "?", expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("eat_block_comment"), hint: None }, par_loc: "(", args: [] } }] }] }) }) }, Arm { pats: [Hole], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "block_comment_beg" })] }), expr: Some(Block { inner_attrs: [], stmts: [Expr { expr: UnaryOp { op: Try, op_loc: "?", expr: MemberCall { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), func: Name { name: Ok("eat_block_comment"), hint: None }, par_loc: "(", args: [] } }, semi: Ok(()) }], ret: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }) }, Arm { pats: [BindLike { name: Ok("m"), ref_: None, mut_: None, pat: None }], cond: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("is"), hint: None }] }), par_loc: "(", args: [Literal(StrLike { is_bytestr: false, s: "delimiter" })] }), expr: Some(Block { inner_attrs: [], stmts: [Item(Item { outer_attrs: [], pub_: None, detail: UseAll { path: Path { is_absolute: false, comps: [Self_("self"), Name { name: Ok("Delimiter"), hint: None }] }, semi: Ok(()) } }), Let { pat: BindLike { name: Ok("is_open"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), arms: Some([Arm { pats: [Literal(StrLike { is_bytestr: false, s: "(" }), Literal(StrLike { is_bytestr: false, s: "[" }), Literal(StrLike { is_bytestr: false, s: "{" })], cond: None, expr: Some(Literal(Bool(true))) }, Arm { pats: [Hole], cond: None, expr: Some(Literal(Bool(false))) }]) }), semi: Ok(()) }, Let { pat: BindLike { name: Ok("delim"), ref_: None, mut_: None, pat: None }, ty: None, expr: Some(Match { kw_loc: "match", expr: Path(Path { is_absolute: false, comps: [Name { name: Ok("m"), hint: None }] }), arms: Some([Arm { pats: [Literal(StrLike { is_bytestr: false, s: "(" }), Literal(StrLike { is_bytestr: false, s: ")" })], cond: None, expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("Paren"), hint: None }] })) }, Arm { pats: [Literal(StrLike { is_bytestr: false, s: "[" }), Literal(StrLike { is_bytestr: false, s: "]" })], cond: None, expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("Bracket"), hint: None }] })) }, Arm { pats: [Hole], cond: None, expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("Brace"), hint: None }] })) }]) }), semi: Ok(()) }], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Delimiter"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("is_open"), expr: None }, Field { name: Ok("delim"), expr: None }]), base: None }] }) }) }, Arm { pats: [Hole], cond: None, expr: Some(PluginInvoke(PluginInvoke { name: Ok("unreachable"), ident: None, tt: Some((Tree { delim: Paren, tts: [] }, "()")) })) }]) }] }) }) }), semi: Ok(()) }], ret: Some(Match { kw_loc: "match", expr: Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("f"), hint: None }] }), par_loc: "(", args: [] }, arms: Some([Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [BindLike { name: Ok("None"), ref_: None, mut_: None, pat: None }] }], cond: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })] }] }) }, Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [BindLike { name: Ok("tokty"), ref_: None, mut_: None, pat: None }] }] }], cond: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Tuple([Path(Path { is_absolute: false, comps: [Name { name: Ok("tokty"), hint: None }] }), UnaryOp { op: Borrow, op_loc: "&", expr: Index { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] }), brk_loc: "[", index: BinaryOp { op: Range, op_loc: "..", l: Path(Path { is_absolute: false, comps: [Name { name: Err(""), hint: None }] }), r: BinaryOp { op: Sub, op_loc: "-", l: MemberCall { obj: Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] }), func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] }, r: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }, func: Name { name: Ok("len"), hint: None }, par_loc: "(", args: [] } } }, unknow: [] } }])] }] }] }) }, Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }, elems: [BindLike { name: Ok("e"), ref_: None, mut_: None, pat: None }] }], cond: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("loc"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("slast"), hint: None }] })) }, Field { name: Ok("kind"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("e"), hint: None }] })) }]), base: None }] }] }) }]) }) }), else_expr: Some(Some(Block { inner_attrs: [], stmts: [], ret: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("loc"), expr: Some(StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("rest"), hint: None } }) }, Field { name: Ok("kind"), expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("UnknowToken"), hint: None }] })) }]), base: None }] }] }) })) })) }) } } }] }) } }, Item { outer_attrs: [], pub_: None, detail: ImplType { templ: [Lifetime { name: "input", bound: None }], ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lexer"), hint: None }] }, args: Some([Lifetime("input")]) }), whs: None, inner: Some(Mod { inner_attrs: [], items: [Item { outer_attrs: [], pub_: Some("pub"), detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("new"), templ: [], args: Some([Bind { pat: BindLike { name: Ok("input"), ref_: None, mut_: None, pat: None }, ty: Some(Ref { lt: Some("input"), mut_: None, ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("str"), hint: None }] }, args: None }) }) }]), va: None, ret_ty: Some(Self_), whs: None }, body: Block { inner_attrs: [], stmts: [], ret: Some(Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lexer"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("tokenizer"), expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Tokenizer"), hint: None }, Name { name: Ok("new"), hint: None }] }), par_loc: "(", args: [Path(Path { is_absolute: false, comps: [Name { name: Ok("input"), hint: None }] })] }) }]), base: None }) } } }] }) } }, Item { outer_attrs: [], pub_: None, detail: ImplTrait { templ: [Lifetime { name: "input", bound: None }], tr: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Iterator"), hint: None }] }, args: None }), ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Lexer"), hint: None }] }, args: Some([Lifetime("input")]) }), whs: None, inner: Some(Mod { inner_attrs: [], items: [Item { outer_attrs: [], pub_: None, detail: Type { alias: Ok("Item"), templ: [], whs: None, origin: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Result"), hint: None }] }, args: Some([Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Token"), hint: None }] }, args: Some([Lifetime("input")]) })), Ty(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: Some([Lifetime("input")]) }))]) })), semi: Ok(()) } }, Item { outer_attrs: [], pub_: None, detail: Func { sig: FuncSig { unsafe_: None, abi: Normal, name: Ok("next"), templ: [], args: Some([SelfRef { mut_: Some("mut") }]), va: None, ret_ty: Some(Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("Option"), hint: None }] }, args: Some([Ty(Self_), Unknow((Token(Symbol(ColonColon)), "::")), Unknow((Token(Ident("Item")), "Item"))]) })), whs: None }, body: Block { inner_attrs: [], stmts: [], ret: Some(Loop { label: None, body: Some(Block { inner_attrs: [], stmts: [], ret: Some(Return { kw_loc: "return", expr: Some(Match { kw_loc: "match", expr: MemberCall { obj: StructField { obj: Path(Path { is_absolute: false, comps: [Self_("self")] }), field: Name { name: Ok("tokenizer"), hint: None } }, func: Name { name: Ok("next"), hint: None }, par_loc: "(", args: [] }, arms: Some([Arm { pats: [BindLike { name: Ok("None"), ref_: None, mut_: None, pat: None }], cond: None, expr: Some(Path(Path { is_absolute: false, comps: [Name { name: Ok("None"), hint: None }] })) }, Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [BindLike { name: Ok("None"), ref_: None, mut_: None, pat: None }] }] }], cond: None, expr: Some(Continue { label: None, kw_loc: "continue" }) }, Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [Tuple([BindLike { name: Ok("tokty"), ref_: None, mut_: None, pat: None }, BindLike { name: Ok("s"), ref_: None, mut_: None, pat: None }])] }] }] }], cond: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Ok"), hint: None }] }), par_loc: "(", args: [Tuple([Path(Path { is_absolute: false, comps: [Name { name: Ok("tokty"), hint: None }] }), Path(Path { is_absolute: false, comps: [Name { name: Ok("s"), hint: None }] })])] }] }) }, Arm { pats: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }, elems: [DestructTuple { name: Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }, elems: [DestructNormal { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, fields: [Field { name: Ok("loc"), pat: None }, Field { name: Ok("kind"), pat: None }], ellipsis: false }] }] }], cond: None, expr: Some(Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Some"), hint: None }] }), par_loc: "(", args: [Call { func: Path(Path { is_absolute: false, comps: [Name { name: Ok("Err"), hint: None }] }), par_loc: "(", args: [Struct { ty: Apply(Angle { name: Path { is_absolute: false, comps: [Name { name: Ok("LexicalError"), hint: None }] }, args: None }), fields: Some([Field { name: Ok("loc"), expr: None }, Field { name: Ok("kind"), expr: None }]), base: None }] }] }) }]) }) }) }) }) } } }] }) } }] }
